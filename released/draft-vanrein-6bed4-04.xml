<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes" ?>
<?rfc compact="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc subcompact="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>

<rfc ipr="trust200902" docName="draft-vanrein-6bed4-04" category="info">



<front>
	<title abbrev="6bed4">6bed4: IPv6 Anywhere in support of Reliable Peering</title>
	<author initials="R" surname="Van Rein" fullname="Rick van Rein">
		<organization>OpenFortress B.V.</organization>
		<address>
			<postal>
				<street>Haarlebrink 5</street>
				<city>Enschede</city>
				<region>Overijssel</region>
				<code>7544 WP</code>
				<country>The Netherlands</country>
			</postal>
			<email>rick@openfortress.nl</email>
		</address>
	</author>
	<date day="9" month="July" year="2020"/>
	<abstract>
   <t>The purpose of 6bed4 is to support IPv6-only networks, hosts and applications.
   It passes IPv6 frames over UDP between IPv4 sites.  Peers connected over 6bed4 can
   switch to direct routes over UDP/IPv4 after deducing that this will be reliable.</t>

   <t>6bed4 lets peer-to-peer applications benefit from transparant addressing in IPv6
   and delegates NAPT concerns to 6bed4.  It is possible to use 6bed4 as a fallback for
   IPv6, or as an additional route.  Servers can be setup as IPv6-only servers with NAT64
   for IPv4-only customers who only need client-server facilities, and add a 6bed4router
   to also facilitate reliable peer-to-peer protocols.</t>
	</abstract>
</front>


<middle>

<section title="Terminology" anchor="terms">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
RFC 2119 <xref target="RFC2119"/>.</t>

<!--
<t>
<list style="hanging">

<t hangText="6bed4 Frame:">A network frame or packet that consists of an IPv6 frame encapsulated into UDP and then into IPv4.</t>

<t hangText="6bed4 Address:">The combination of an IPv4 address and a UDP port number.  This pair of coordinates is used to indicate a UDP/IPv4 endpoint for 6bed4 Frames.   A Source 6bed4 Address is a 6bed4 Address comprising of a source IPv4 address and source UDP port; a Destination 6bed4 Address is a 6bed4 Address comprising of a destination IPv4 address and destination UDP port.  A 6bed4 Address is called Direct if it represents the coordinates of a 6bed4 Peer; a 6bed4 Address is called a Fallback if it addresses a 6bed4 Server.</t>

<t hangText="6bed4-Prefixed Address:">An IPv6 address that begins with the standard prefix TBD1::/32 which implies that the rest of the address holds the IPv4 address of a 6bed4 Server and (usually) a Direct 6bed4 Address.</t>

<t hangText="6bed4 Server:">A router in the 6bed4 communication path.  When receiving 6bed4 Frames, it is validated and either relayed as native IPv6 traffic or bounced as a 6bed4 Frame towards the destination's 6bed4-Prefixed Address.  In addition, a 6bed4 Server takes care of a few discovery tasks.</t>

<t hangText="6bed4 Peer:">An endpoint in the 6bed4 communication path.  These are places where IPv6 traffic is wrapped into 6bed4 Frames, or unwrapped.  Note that configurations may exist where further communication over IPv6 takes place, but the peer remains the endpoint for 6bed4-embedded frames.</t>

<t hangText="6bed4 Infrastrucure:">The combination of 6bed4 Peers and 6bed4 Servers.</t>

<t hangText="/n Prefix:">When n is less than 32, we use this notation to refer to an IPv4 prefix.  When n is at least 32, we use this notation to refer to an IPv6 prefix.</t>

<t hangText="/32+n Prefix:">This is always an IPv6 prefix, with a length of 32+n bits, with n at least 0 and at most 32.  The first 32 bits and the first 32 bits of TBD1:: are the same.  This notation improves readability when /32+n prefixes in a 6bed4-Prefixed Address are compared to /n prefixes in IPv4 addresses.</t>

<t hangText="Native IPv6 Address:">An IPv6 address that is not routed over 6bed4, Teredo <xref target="RFC4380"/> or 6to4 <xref target="RFC3056"/>.  In other words, an IPv6 address that matches none of the prefixes TBD1::/32, 2001:0000::/32, 2002::/16.  Synonyms used in this document are "native address", or simply "native".</t>

<t hangText="Internal Address:">An IPv4 address as specified in <xref target="RFC1918"/> or <xref target="RFC6598"/>, or an IPv6 address defined as Link-Local in <xref target="RFC4291"/>.</t>

<t hangText="Public Address:">Informally, an address as observed by any arbitrary observer on the public Internet, so outside of any layer of Network Address/Port Translation.  Formally, it is defined as any address that is not an Internal Address.</t>

<t hangText="NAT:">A translation mechanism, usually located in an IPv4 router, that rewrites Internal Addresses (and ports) into Public Addresses (and ports), and conversely.  Very often, the translation from Public to Internal Addresses (and ports) is constrained by local policy.</t>

<t hangText="UDP/IPv4 Stream:">A term that loosely refers to the back-and-forth exchanges of UDP frames over IPv4 between two specific 6bed4 Addresses.  Note that the 6bed4 protocol sends keepalive messages to keep a started stream open with respect to filtering and address/port translation.</t>

<t hangText="6bed4 Connection:">The exchange of 6bed4 Frames between two 6bed4 endpoints.  This is run over an UDP/IPv4 Stream.  When the endpoints of that stream are both Direct 6bed4 Addresses, then the 6bed4 connection is also called Direct.  Otherwise, the 6bed4 Connection may be referred to as a Fallback connection to make explicit that frames travel through at least one 6bed4 Server.</t>

<t hangText="Endpoint-Dependent Mapping:">Any mapping between 6bed4 Addresses that is not an endpoint-independent mapping according to <xref target="RFC4787"/>.  In terms of this RFC, for some values of Y2:y2 the value of X1':x1' differs from X2':x2'.</t>


</list>
</t>
-->

</section>



<section title="Introduction" anchor="intro">

<t>Several tunnels for IPv6 have been proposed <xref target="RFC7059"/>; the novelty of 6bed4 is that it allows the assumption that IPv6 is everywhere; not only can it be implemented for hosts or networks, but even inside an application.  As a result, application developers can rely on transparant IPv6 addressing, even when their code is distributed over a network that may include IPv4-only users.  Currently unsupported use cases such as SIP/RTP, direct file transfer and other peer-to-peer protocols can benefit from the relative simplicity of this model and the knowledge that traffic either transfers directly between peers, or reflects through a relay of the user's choosing.</t>

<t>To carry IPv6 anywhere, 6bed4 transports it as a UDP payload, contained in UDP/IPv4.  The UDP port and IPv4 address are derived from the IPv6 address on sending, and validated to match upon arrival.  This means that much of the 6bed4 infrastructure can be stateless, like a router.  In addition, IPv4 attackers are still traceable when they use 6bed4 to step up to IPv6.</t>

<t>The 6bed4 network consists of any number of 6bed4peers running IPv6 applications and usually a 6bed4router that defines a prefix under which it reliably connects peers, and through which it may route to and from native IPv6 addresses.  To optimise routing, one 6bed4peer may choose to access multiple 6bed4routers, but automatic detection of crossover between 6bed4peers under different 6bed4routers is also possible.</t>


<section title="Address Format" anchor="intro.addrs">

<t>The structure of a 6bed4 address may involve a specialised top half structure in the /64 prefix and/or a specialised bottom half structure following it.  The format of a 6bed4 address with both specialised parts is:</t>

<figure><!-- <preamble>Conceptual Representation of a 6bed4 Address</preamble> -->
<artwork>
|  32 bits |          32         |          50             |  14   |
+----------+---------------------+-------------------------+-------+
|  prefix  | 6bed4router address | direct 6bed4peer address| lanid |
+----------+---------------------+-------------------------+-------+
</artwork>
</figure>

<t>Whether the top half is a 6bed4 address depends on the prefix.  The prefix TBD1::/32 globally defines a 6bed4 address, and supports routing across the Internet.  Prefixes fc64:&lt;netid&gt;::/32 for any &lt;netid&gt; are interpreted as 6bed4 addresses when they occurs on the 6bed4 network, but this interpretation cannot be generally prescribed.  These /32 prefixes permit the interpretation of the top half, where bits 32..64 hold the IPv4 address of a 6bed4router that can further relay the traffic.  Any IPv6 router may pass TBD1::/32 by forward the IPv6 packet over UDP/IPv4 to port TBD2 and the address in the IPv6 top half.</t>

<t>Any /64 prefix that is a destination address on the 6bed4 network must adhere to this format for the lower half.  These are prefixes announced by 6bed4router and 6bed4peer components, extended to a /114 in a Router Advertisement and having the L and A flags set.  Traffic with a 6bed4peer source address never came from a routed backend, so source addresses arriving over direct peering instead of from a subscribed-to 6bed4router can also be considered to have a 6bed4 lower half.  This lower half contains the IPv4 address and UDP port, as observed by an addressed party.</t>

</section> <!-- Introduction: Address Format -->


<section title="Protocol Description" anchor="intro.protocol">

<t>The role of a 6bed4router is to be the defining home for one /64 prefix and potentially connect to other IPv6 addresses.  It binds a UDP socket to a static IPv4 address and the standard UDP port TBD2.</t>

<t>Every 6bed4peer opens a UDP socket and is identified by one or more external pairs of an IPv4 address and UDP port.  The UDP socket is seen as a /64 prefix, usually obtained from a 6bed4router, extended into to as many /114 prefixes as the 6bed4 network has external address/port pairs for its UDP/IPv4 socket.</t>

<t>When a 6bed4peer desires to run under the /64 prefix of a given 6bed4router, it sends a Router Solicitation to its UDP/IPv4 address.  The response is an initial Router Advertisement that offers a /114 prefix, consisting of the /64 of the 6bed4router externded with the UDP/IPv4 address of the 6bed4peer, as observed by the 6bed4router.  This /114 must be used as the source address in future communications with that 6bed4router.  A 6bed4peer sends Keepalive messages to keep the NAPT mapping towards the 6bed4router open as a reliable bidirectional routing path.</t>

<t>When attempting direct peering, the UDP/IPv4 destination address of a remote 6bed4peer is collected from its /114 and a direct UDP/IPv4 message is attempted.  This may or may not succeed, so the initial attempt is usually a Probe that may result in a future report of a Seen flag.  In reliable modes of operation, the initial traffic is sent through the 6bed4router until it learns that direct peering is possible; more agressive but less reliable peering policies are defined as alternatives.</t>

<t>Traffic on the 6bed4 network is validated to hold an IPv6 source address with a lower half mentioning the source UDP/IPv4 address.  Failure to match rejects the message with a corrective Router Advertisement in return.  This allows a 6bed4peer to communicate directly with any 6bed4peer, and to learn of another external UDP/IPv4 address for its UDP socket in relation to other network components.</t>

</section> <!-- Introduction: Protocol -->

<section title="Use Cases" anchor="intro.usecase">

<t>The 6bed4peer can be run for a network, a machine or even a single application.  It can add IPv6 to any machine that supports IPv4, whether it already supports IPv6 or not.</t>

<t>The 6bed4router can share a /64 prefix to any number of 6bed4peer nodes.  It may offer additional routes to network regions that can route back to this /64 prefix, including an offering of a default route if the shared prefix is globally routable.</t>

<t>Applications may benefit from the certainty that IPv6 is available, especially when they run their own 6bed4 network.  They would normally want to connect to a 6bed4router at its specified IPv4 address and UDP port TBD2 and obtain a /114 prefix holding their own IPv4/UDP address.  The final 14 lanid bits allow a range of addresses to divide as the 6bed4peer sees fit.</t>

<t>Peer-to-peer applications may prefer to evade the 6bed4router and prefer direct peering, at least when both peers are known to use 6bed4 address bottom halves.  This may not always succeed, mostly dependent on NAPT properties which cannot generally be solved.  The desired peering policy can be specified in each frame, and peering success or failure can be learnt from received frames, so preferences among alternative routes could be based on peering properties.</t>

<t>The reliable and desired-direct approaches can be mixed, because the peering policy is separately set in the traffic class for each IPv6 frame.  An application might connect (perhaps with SIP) through a 6bed4router and use a direct-peering data path (perhaps with RTP) afterwards.  It is possible to bind to another address for RTP than for SIP, and the addition of Keepalive messages can even support non-symmetric RTP streams; all this can help to find direct routes where they are possible, and thus rely on a minimum of fallback routing through the 6bed4router.</t>


</section> <!-- Introduction: Use Cases -->

</section> <!-- Introduction -->



<section title="6bed4 Network Components" anchor="_6bed4net">

<t>This section describes common aspects that apply to 6bed4peers as well as 6bed4routers.  Later sections specify aspects that these components add.</t>

<t>Every component on the 6bed4 network opens a UDP port over which it sends and receives IPv6 frames.  The further processing of these frames depends on the component.</t>


<section title="IPv6 Address Validation" anchor="_6bed4net.validate">

<t>Upon arrival of an IPv6 frame over UDP/IPv4, the IPv6 source (and destination) address is verified.  This usually involves testing an IPv6 address to have a lower half containing an IPv4 address and UDP port, almost in network bit order.  The lower half must follow this format:</t>

<figure><!-- <preamble>6bed4 Bottom Half</preamble> -->
<artwork>
<![CDATA[
 |      6      |  2    |     24       |   16  |      2      |   14  |
-+-------------+-------+--------------+-------+-------------+-------+
 | IPv4 [0..5] | EIU64 | IPv4 [8..31] |  UDP  | IPv4 [6..7] | lanid |
-+-------------+-------+--------------+-------+-------------+-------+
]]>
</artwork>
</figure>

<t>The IPv4 address is split into portions [N..M] with bits N to M,
counting from 0 for the high end.  The IPv4 address effectively
has two bits taken out to conform to the EUI-64 address format <xref target="RFC3513"/>.
The overlaid IPv4 address bits follow after the UDP port.  The last
14 bits form the lanid, which can be freely used on the component
bound to the given UDP port and IPv4, except for the value 0, which
is reserved for the 6bed4router for this IPv6 address.</t>

<!-- TROUBLE WHEN /64 EXPORTS FROM A 6BED4PEER
<t>UDP port value 0 and IPv4 address 0.0.0.0 would each render the
6bed4 bottom half invalid, but when it occurs on the 6bed4 network it
is considered bound to the component that introduces the /64
prefix on the 6bed4 network.</t>
-->

</section> <!-- 6bed4net.validate -->

<section title="Router Solicitation and Advertisement" anchor="_6bed4net.advert">

<t>When a local 6bed4 component intends to connect to a remote 6bed4 component, it may send a Router Solicitation [Section 4.1 of <xref target="RFC4861"/>] to the IPv4 address and UDP port of the remote.  The prefix supplied can be used after the remote sends back a Router Advertisement [Section 4.2 of <xref target="RFC4861"/>], the composition of which is
<list style="symbols">
<t>Flags [Section 3 of <xref target="RFC5175"/>] are M=0, O=0, H=0, P=0.</t>
<t>A prefix of length /114, where the /64 portion defines the 6bed4 network and the added 50 bits hold the local component's UDP port and IPv4 address as observed by the remote 6bed4 component.  The trailing 14 bits are the lanid; lanid 0 is reserved for the router, but the other 16383 values may be used freely by the local component, perhaps through DHCPv6.</t>
<t>Any number of routes, possibly including a default route.  Any route MAY be ignored by the local 6bed4 component.  Routes only make sense when the reachable prefixes can route traffic back to the remote 6bed4 component; a 6bed4peer SHOULD NOT offer routes because it is considered a terminal in the 6bed4 network, rather than an authoritative source of routes.</t>
</list></t>

<t>Every component on the 6bed4 network SHOULD send a Router Advertisement to correct an invalid bottom-half <xref target="_6bed4net.validate"/> in an IPv6 source address.  This allow the sending 6bed4 component to correct its own idea of its externally observed UDP/IPv4 address, at least towards the designated recipient.  The bits that would change are the bottom-half bits holding its IPv4 address and UDP port; note that the lanid is always zero in a /114 prefix.</t>

</section> <!-- 6bed4net.advert -->

<section title="Network Prefixes" anchor="_6bed4net.prefix">

<t>The 6bed4 network uses /114 prefixes for its destination addresses.  These addresses contain a UDP/IPv4 address in their bottom half, following a /64 prefix in the address top half.  The top half is considered the identity of a 6bed4 network segment, as ususally defined by a 6bed4router and sometimes by a 6bed4peer.  The top half never changes while processing a corrective Router Advertisement; it does however get assigned by the initial Router Advertisement that follows up on a Router Solicitation.</t>

<t>Even if a 6bed4peer obtains a /64 prefix from a 6bed4router as part of a /114 in an initial Router Advertisement, and even though it is not a router for that address, it may nonetheless use the /64 to construct a /114 towards other 6bed4peers.  This bottom-half logic is a point where 6bed4 destination addresses have more semantics than general IPv6.  Two 6bed4peers may use Router Solicitation and/or Router Advertisements to learn about each other's view on their addresses.  This behaviour is not required for reliable exchanges, but it can help to pierce through more kinds of NAPT router; it is why the /64 is said to describe a 6bed4 network, rather than just the component that introduces it.</t>

<t>Typical for IPv6, there is some variation in use cases for different prefix kinds.  We distinguish native prefixes, locally routed prefixes and specific 6bed4 prefixes.</t>

<section title="Native /64 Prefixes" anchor="_6bed4net.prefix.native">

<t>Every 6bed4 component can export a native /64 prefix, provided that it can route to it and that the native prefix is routed back to it.  This facility allows sharing that prefix to connecting other components; do note that no access control exists, but the bottom half of an IPv6 address under the prefix reveals the validated UDP/IPv4 address of a source.</t>

<t>The top-half of a native prefix is not recognised as a 6bed4 address, as it is not possible to extract a 6bed4router IPv4 address from it.  As a result, its traffic usually passes over native IPv6 routes.  The benefit of a publicly routable IPv6 address is that it can be used in connections to arbitrary other IPv6 addresses that are also globally routable.</t>

<t>Some hosts have only one /64 available, and may want to mix 6bed4 with services.  Although invalid 6bed4 bottom halves (for instance, UDP port 0) could be allocated for other uses than 6bed4, this is NOT RECOMMENDED because it would break connectivity for other 6bed4 components when the prefix is passed through the 6bed4 network via Router Advertisements.  Instead, the RECOMMENDED procedure would be to setup IPv6 addresses as available to a locally run 6bed4peer on a fixated public IPv4 address and UDP port; the 6bed4 component software may optimise handling for these purposes.</t>

</section> <!-- 6bed4net.prefix.native -->

<section title="Locally Routed fc00::/7 Prefixes" anchor="_6bed4net.prefix.local">

<t>Some IPv6 addresses have been allocated for local routing <xref target="RFC4193"/>.  The fc00::/7 prefix is divided into administratively assigned fc00::/8 prefixes and randomly completed fd00::/8 prefixes.  With the exception of fc64::/16 discussed below, these addresses are locally routed, also on a 6bed4 network.</t>

<t>Local routes cannot be used to communicate with native IPv6 address, unless they happen to be aware of how to return the traffic.  Such native routes in the direct backend of a 6bed4router can be explicitly mentioned in its Router Advertisement, even for a fc00::/7 prefix.</t>

<t>Locally routed addresses can only be communicated with the 6bed4 component that defines them.  Because of this, they MUST NOT be further transmitted through Router Advertisement; connections are 1:1 only.  Whether this is a 6bed4peer to a 6bed4router (reliable) or a 6bed4peer to another 6bed4peer (not reliable) is a matter of application or network configuration.</t>

<t>It is quite possible for a 6bed4peer to setup a random /64 prefix based on fd00::/8, and peers might even form networks between such addresses, possibly based on a distributed hash table.  In such networks, redundancy can be helpful to overcome unreliable direct peering connections.  As explained below, 6bed4 can support the detection of reliability.</t>

</section> <!-- 6bed4net.prefix.local -->

<section title="The 6bed4 fc64::/16 and TBD1::/32 Prefixes" anchor="_6bed4net.prefix.6bed4">

<t>The prefixes fc64::/16 and TBD1::/32 mark what are called 6bed4 prefixes.  The fc64::/16 prefix receives an additional network identifier &lt;netid&gt; to form fc64:&lt;netid&gt;::/32.  These /32 prefixes are used in a top half, whose format is completed with the IPv4 address of a 6bed4router, in network byte order:
<figure><!-- <preamble>6bed4 Bottom Half</preamble> -->
<artwork>
<![CDATA[
|               32               |               32               |
+--------------------------------+--------------------------------+-
|      fc64:<netid> or TBD1      |   IPv4 address of 6bed4router  |
+--------------------------------+--------------------------------+-
]]>
</artwork>
</figure>
</t>

<t>The 6bed4router is responsible of knowing its public IPv4 address.  The fixed UDP port on which the 6bed4router provides its service MUST be TBD2.  As a result, a network component that can interpret the prefix as a 6bed4 prefix can route the traffic over the 6bed4 network.  For the TBD1::/32 prefix, this can be any party on the Internet; for fc64::/16 it can only be assumed when the address is found on the 6bed4 network.  The added value of TBD1::/32 over fc64::/16 therefore is that it expands the IPv6-everywhere facilitation of 6bed4 from an overlay network to a globally routed network.</t>

<t>The 6bed4router is vital in the reliability of the 6bed4 network:
<list style="symbols">
<t>The 6bed4router is always reachable at its IPv4 address and the fixed UDP port TBD2;</t>
<t>The 6bed4router can always reach every 6bed4peer that subscribes to its serviced prefix.</t>
</list>
This means that a conservative route can always be made through a 6bed4router.  This is also possible when the prefixes differ, either in the IPv4 address or also in the /32 part.  Within the constraints of source address validation, it is possible to route traffic through the 6bed4router covering the source prefix and the 6bed4router covering the destination prefix; or it is possible to route traffic through the 6bed4router of a destination node, after a source 6bed4peer (also) connects to the destination's 6bed4router.</t>

<t>Another value of the 6bed4 prefix is that they represent end points on the 6bed4 network.  This means that the bottom half can also be interpreted and used for direct 6bed4 traffic.  This usually works best when the source address is then also chosen to be a 6bed4 address, which can be achieved under normal address binding rules when a low-priority interface offers routes for fc64::/16 or TBD1::/32 with a prefix under either.</t>

</section> <!-- 6bed4net.prefix.local -->

</section> <!-- 6bed4net.prefix -->

</section> <!-- 6bed4net -->



<section title="The 6bed4peer Component" anchor="_6bed4peer">

<t>The 6bed4peer opens a UDP socket over which it sends and receives IPv6 frames.
The UDP remote end can be any number of 6bed4peers and/or 6bed4routers.
A basic configuration would communicate with a single 6bed4router which may be its default route to native IPv6 addresses, and as many 6bed4peers as it can connect to directly.</t>

<t>To be able to route under a 6bed4router's prefix, the 6bed4peer sends a Router Solicitation and awaits an initial Router Advertisement <xref target="_6bed4net.advert"/> to learn about its /114 prefix, which includes the /64 prefix provisioned by the 6bed4router.  The 6bed4peer MAY configure any additional routes provided in a Router Advertisement from a 6bed4router.  Through the Router Advertisement, the 6bed4peer learns about the external address of its UDP socket, as observed by the 6bed4router.  Over this route, the 6bed4peer will send regular Keepalive messages to keep the NAPT traversal open and guarantee a reliable incoming route through the 6bed4router.  A generally advised minimum frequency for Keepalive messages is once in 30 seconds.</t>

<section title="6bed4peer Forwarding" anchor="_6bed4peer.fwd">

<t>To submit an IPv6 frame on the 6bed4 network, a 6bed4peer first determines whether it can forward to a 6bed4router or directly to a 6bed4peer:
<list style="symbols">
<t>When source and destination share the same /64 prefix, consider direct routing as well as the 6bed4router.</t>
<t>When the destination is a 6bed4 prefix and the source and destination have different /64 prefixes, consider direct routing as well as the 6bed4router.</t>
<t>When the destination has another prefix (that was offered and accepted as a route from a 6bed4router), consider going through the 6bed4router.</t>
</list></t>

<t>When a direct route is considered, the default peering policy <xref target="peerpol"/> only uses direct peering when it is known to be reliable <xref target="reliable"/>.  Other peering policies provide variations on a frame-by-frame basis, to allow for maximum flexibility.  When direct routing is selected, any considerations of going through the 6bed4router are dropped.</t>

<t>When considering the 6bed4router, the /64 prefix of the source address determines which one to use.  When the source and destination have 6bed4 addresses with different /64, the traffic bounces through both 6bed4routers, which is useful to validate the traffic for not forging IPv6 addresses.  To avoid this "trapeziums-shaped" routing, it is also possible for a 6bed4peer to bind an address under the destination address's 6bed4router by sending a Router Solicitation and acquiring a /114 prefix to work from.  The result would be only one 6bed4router bouncing the traffic instead of two.  Whether or not this is done, direct peering may be discovered as reliable alternative and either shape bypassed completely.</t>

<t>The IPv6 frame can now be sent over the 6bed4 network, from the UDP socket held by the 6bed4peer.  The remote UDP port and IPv4 address are learnt from the bottom half of the destination IPv6 address.  Since a 6bed4peer is not supposed to route traffic, any source address is supposed to be locally bound, therefore be a 6bed4 address, and so its bottom half is supposed to contain the external view on its UDP port and IPv4 address.</t>

<t>Although it makes less sense for UDP than for TCP, NAPT middleware may have imposed an Endpoint-Dependent Mapping <xref target="RFC4787"/>, which means that the external UDP port and IPv4 address observed by the 6bed4router form a reasonable initial guess when communicating directly with other 6bed4peers, but there may be a need to correct these aspects when communicating with such 6bed4peers.  To this end, a remote peer might send a corrective Router Advertisement and the IPv6 frame would be lost.  This should not happen when reliability rules are obeyed, but it may happen for frames that select another peering policy than the default.</t>

<t>Note how this opens degrees of freedom to the an application acting as/via a 6bed4peer.  For general TCP or SCTP, a first SYN or INIT frame might be sent under a peering policy that enforces direct peering, and fall back to reliable routing when resent.  And a application could send SIP messages over reliable patterns, but work towards direct peering for RTP; a SIP/SDP offer can welcome RTP traffic on a 6bed4 address, possibly using a 6bed4router in a SIP/SDP offer that was just received; many SIP networks are closed, and could opt to be IPv6-only networks, with 6bed4 as a reliable fallback option.</t>

</section> <!-- 6bed4peer.fwd -->

<section title="6bed4peer Filtering" anchor="_6bed4peer.filt">

<t>Anyone might send packets to the UDP socket of a 6bed4peer, but not all traffic should pass.  Specifically, filtering on the IPv4/UDP source address in relation to the IPv6 source address is necessary to stop peers from claiming arbitrary IPv6 addresses.</t>

<t>Traffic without a full IPv6 header is exceptional, and considered to be a Probe; an attempt to reach our UDP socket through direct peering.  This is not routed any further, but it counts as successful input under direct peering.  Usually sent before or after an IPv6 frame via the 6bed4router, it permits flagging that this direct input succeeded on return traffic to that same 6bed4peer.</t>

<t>There are two reasons why an IPv6 header's source address might be acceptable; it could be from a 6bed4router to which the receiving 6bed4peer maintains an uplink, or it might be a direct connection from another 6bed4peer under the same 6bed4router.  On top of this, a third reason to accept an IPv6 header is when its source and destination address together indicate that a bypass of a trapezium route is made.</t>

<t>The 6bed4peer should know the 6bed4routers to which it maintains an uplink; it needs this information for sending Keepalives that maintain an open NAPT mapping.  Each 6bed4router can be uniquely identified by matching their IPv4 address and UDP port against the UDP/IPv4 source address of an incoming frame.</t>

<t>A frame sent directly from another 6bed4peer working under the same 6bed4router will use a /64 prefix that we got from that 6bed4router.  As a result, we can rely on the bottom half address to contain a IPv4 address and UDP port, which MUST then match the source of the incoming frame.  When the /64 prefix matches but the bottom half does not, a corrective Router Advertisement SHOULD be sent (possibly with a limited frequency).  TODO:REQUIRE_SRC/64_IS_DST/64?</t>

<t>The bypass for a trapezium route is more complicated.  In this case, the frame came from a 6bed4peer acting under another 6bed4router.  The frame was first passed to the source's 6bed4router and then the destination's.  When the latter delivers the frame at the 6bed4destination, the source and destination IPv6 address are used.  First, both addresses MUST be 6bed4 addresses, so have either the fc64::/16 or TBD1::/32 prefix, in any combination.  Second, the 6bed4router addresses in the top half are considered; the source 6bed4router address is assumed to have been validated by our 6bed4router; the destination 6bed4router address MUST be found as one to which we maintain an uplink.  Third, the source IPv4 address and UDP port MUST be set in the bottom half of the source IPv6 address.  Fourth, our IPv4 address and UDP port according to our 6bed4router (which is mentioned in the top half of the IPv6 destination address) MUST match the bottom half of the IPv6 destination address.  Failure on any of these four conditions leads to discarding of the frame as a suspect frame.</t>

</section> <!-- 6bed4peer.filt -->

</section> <!-- 6bed4peer -->



<section title="The 6bed4router Component" anchor="_6bed4router">

<t>The 6bed4router is a stateless component.  It can be reached reliably on a static IPv4 address on the fixed UDP port TBD2, so it can be reached by all 6bed4 components.  If a NAPT mapping applies, it is a static mapping.</t>

<t>Every 6bed4router defines its own /64 prefix and when this is a 6bed4 address its static IPv4 address is contained in the IPv6 address top half that forms this prefix.  In addition to the offered prefix, a 6bed4router may also exchange IPv6 frames with locally routable prefixes and/or with globally routable prefixes anywhere on the Internet.</t>

<t>Among the routes offered may be the default route ::/0.  This is just one of many possible routes.</t>

<t>Another seemingly special route is fc64::/16, which captures more than just a specific fc64:&lt;netid&gt;::/32 that the 6bed4router may use as its prefix.  A route fc64::/16 states that other &lt;netid&gt; values can be routed to the 6bed4router's connected network.  Only the one announced in the prefix is handled directly by the 6bed4router.  Again, there is no need to treat such cases in any special way.  TODO: BUT WE DO TREAT IT ESPECIALLY; IF NOT OUR IPV4 IS USED, WE RELAY SUCH A PREFIX.  SAME FOR TBD1::/32 BY THE WAY.</t>

<t>Traffic that arrives over the 6bed4 network is first filtered to be properly formed.  After this, one possible forwarding option is to bounce the frame back into the 6bed4 network, but to another IPv4 address and UDP port.  This is done to relay traffic between two 6bed4peers that share the 6bed4router's /64 prefix but that are not (yet) able or willing to connect directly.  It is also done to relay traffic between two 6bed4routers if their 6bed4peers use different /64 prefixes and are not (yet) able or willing to connect directly; this situation is called trapezium routing and is effectively a bypass for routing over IPv6, mostly to permit fc64::/16 prefixes to work across 6bed4routers' prefixes.</t>

<section title="6bed4router Filtering" anchor="_6bed4router.filt">

<t>The 6bed4router is stateless, but it is careful about filtering traffic before agreeing to route it.  Different filtering rules are applied on the IPv6 side of the 6bed4router than on the side of the 6bed4 network.</t>

<t>Traffic arriving at the IPv6 side is called return traffic.  Traffic arriving over the 6bed4 network can be routed for either local, backend or first and second stage of trapezium routing.</t>

<t>Return traffic MUST be rejected unless:
<list style="symbols">
<t>The destination IPv6 address matches the 6bed4router's defined /64 prefix;</t>
<t>The bottom half of the destination IPv6 address does not mention IPv4 address 0.0.0.0;</t>
<t>The bottom half of the destination IPv6 address does not mention UDP port 0.</t>
</list></t>

<t>Local routing applies when the IPv6 source and destination addresses both use the /64 prefix defined by the 6bed4router.  Local routing MUST be rejected unless:
<list style="symbols">
<t>The bottom half of the IPv6 source address mentions the IPv4 address and UDP port over which the frame arrived from the 6bed4 network;</t>
<t>The bottom half of the IPv6 destination address does not mention IPv4 address 0.0.0.0;</t>
<t>The bottom half of the IPv6 destination address does not mention UDP port 0.</t>
</list></t>

<t>Backend routing applies when the IPv6 source address uses the /64 prefix defined by the 6bed4router, while the IPv6 destination address matches a route announced in Router Advertisements.  TODO:CONSIDER_TRAPEZIUM_ROUTING_FOR_6BED4ADDRS_WITH_DIFFERENT_TOP_IPV4ADDR.  Backend routing MUST be rejected unless:
<list style="symbols">
<t>The bottom half of the IPv6 source address mentions the IPv4 address and UDP port over which the frame arrived from the 6bed4 network.</t>
</list></t>

<t>The first stage of trapezium routing applies when the IPv6 source address uses the /64 prefix defined by the 6bed4router, but the desination IPv6 address neither suggests local or backend routing.  The first stage of trapezium routing MUST be rejected unless:
<list style="symbols">
<t>The source and destination IPv6 addresses are both 6bed4 addresses, though not necessarily the same;</t>
<t>The IPv6 source address matches the /64 prefix of the 6bed4router;</t>
<t>The bottom half of the IPv6 source address mentions the IPv4 address and UDP port over which the frame arrived from the 6bed4 network;</t>
<t>The bottom half of the IPv6 destination address does not mention IPv4 address 0.0.0.0;</t>
<t>The bottom half of the IPv6 destination address does not mention UDP port 0.</t>
</list></t>

<t>The second stage of trapezium routing applies when the IPv6 destination address uses the /64 prefix defined by the 6bed4router, but the source IPv6 address neither suggests local or backend routing.  The second stage of trapezium routing MUST be rejected unless:
<list style="symbols">
<t>The source and destination IPv6 addresses are both 6bed4 addresses, though not necessarily the same;</t>
<t>The IPv4 address over which the frame arrived from the 6bed4 network matches the 6bed4router address in the top half of the IPv6 source address;</t>
<t>The UDP port over which the frame arrived from the 6bed4 network is the standard port TBD2;</t>
<t>The bottom half of the IPv6 destination address does not mention IPv4 address 0.0.0.0;</t>
<t>The bottom half of the IPv6 destination address does not mention UDP port 0.</t>
</list></t>

</section> <!-- 6bed4router.filt -->

<section title="6bed4router Forwarding" anchor="_6bed4router.fwd">

<t>The 6bed4router terminates certain IPv6 destination addresses.  These addresses match the
/64 prefix, and the bottom half defines the IPv4 address at which the 6bed4router can be reached,
along with its standard UDP port TBD2.  Furthermore, any bottom half that specifies lanid value 0
is considered to terminate at the 6bed4router.  Such addresses may have some special treatment
for ICMPv6 traffic, but most other traffic would be relayed to a local interface binding to that
address.  In absense of such a binding, an ICMPv6 error may be sent back.</t>

<t>Return traffic is relayed over the 6bed4 network to the IPv4 address and UDP port found in
the bottom half of the IPv6 destination address.</t>

<t>Local traffic is relayed back over the 6bed4 network to the IPv4 address and UDP port found in
the bottom half of the IPv6 destination address.</t>

<t>Backend traffic is relayed into the backend, normally using the routing table under which
the 6bed4router operates.</t>

<t>The first stage of trapezium routing is relayed over the 6bed4 network to the 6bed4router address
in the top half of the destination IPv6 address and the standard UDP port TBD2.</t>

<t>The second stage of trapezium routing relays over the 6bed4 network to the IPv4 address and
UDP port found in the bottom half of the IPv6 destination address.</t>

</section> <!-- 6bed4router.fwd -->

<section title="Combining 6bed4peer and 6bed4router Functions" anchor="_6bed4router.6bed4peer">

<t>It is possible for a single component to act both as a 6bed4peer and a 6bed4router.
The individual requirements for each apply, specifically resolving potential conflicts with:
<list style="symbols">
<t>The component MUST be externally reachable on a static IPv4 address at the standard UDP port TBD2;</t>
<t>When sending a Router Advertisement, it MUST NOT provide additional routing information.</t>
</list></t>

</section> <!-- 6bed4router.6bed4peer -->

</section> <!-- 6bed4router -->


<section title="Peering Policies" anchor="peerpol">

<t>The IPv6 frame that travels over the 6bed4 network, so between 6bed4 components,
can express its preferred peering policy.  This is expressed through the Traffic
Class, which is spread over two bytes in the IPv6 header.  The value of the
Traffic Class is generally considered <xref target="RFC2474"/><xref target="RFC3168"/>
to follow this structure:
<figure><!-- <preamble>DS/ECN in the Traffic Class</preamble> -->
<artwork>
<![CDATA[
|       6      |  2  |
+--------------+-----+
|      DS      | ECN |
+--------------+-----+
]]>
</artwork>
</figure>
Part of the DS field is interpreted <xref target="RFC2474"/> as a
Class Selector CS:
<figure><!-- <preamble>CS/ECN in the Traffic Class</preamble> -->
<artwork>
<![CDATA[
|    3   |  3  |  2  |
+--------+-----+-----+
|   CS   | 000 | ECN |
+--------+-----+-----+
]]>
</artwork>
</figure></t>

<t>On the 6bed4 network, the interpretation of CS is further split
into a two-bit peering policy PP and a Seen flag S:
<figure><!-- <preamble>Peering Policy and Seen on the 6bed4 Network</preamble> -->
<artwork>
<![CDATA[
|  2 | 1 |  3  |  2  |
+----+---+-----+-----+
| PP | S | 000 | ECN |
+----+---+-----+-----+
]]>
</artwork>
</figure>
The PP and S values may be retained when a frame exits a 6bed4peer
and arrive at an application.  The Seen flag expresses that direct peering
from this side to the source address recently succeeded, even
if just as a Probe.  This means that direct peering to the IPv6
source address is considered reliable for 27 seconds from the
arrival of the frame with the Seen flag.  The 6bed4peer normally takes note of
this flag, and modifies its peering behaviour accordingly.</t>

<t>Before entry into the 6bed4 network, so in the application
that constructs the IPv6 frame to be relayed through a 6bed4peer,
the peering policy PP indicates the desired peering policy, but the
Seen flag has no meaning yet; its place is taken by Adaptive flag A:
<figure><!-- <preamble>Peering Policy and Adaptive Flag entering the 6bed4 Network</preamble> -->
<artwork>
<![CDATA[
|  2 | 1 |  3  |  2  |
+----+---+-----+-----+
| PP | A | 000 | ECN |
+----+---+-----+-----+
]]>
</artwork>
</figure>
The Adaptive flag expresses that the IPv4 address and UDP port in
the bottom half of the source IPv6 address may be modified at
will.  When local NAPT performs Endpoint-Dependent Mapping it
would map the same UDP socket to different external address/port
combinations for different remote peers.  Normally, this makes
the reliable traffic fall back on the 6bed4router, because
there is no basis of trust for the remote that two seemingly
different peers map to the same UDP socket and hence to the
same 6bed4peer.  Through Adaptive source addresses, a prefix
supplied through a corrective Router Advertisement in the past
can be used to construct a suitable source address.  Other than
the Adaptive flag, the 6bed4peer needs no instructions to do this.
The application may learn the new address from replies to a frame
sent with the Adaptive flag.  It is then free to adopt the
address and continue without an Adaptive flag, or to continue and
even allow connected updates to the address when NAPT changes
state.  If and when this can work is up to the application logic.</t>

<t>The four peering policy (PP) values defined for 6bed4 are:
<list style="hanging">
<t hangText="Proper Peering">
	has bit value 00 or decimal value 0 and is the default.
	This policy routes through the source's 6bed4router when
	direct peering has not been detected to be reliable, but 
	as soon as it is considered reliable it switches to
	direct peering.</t>
<t hangText="Prohibited Peering">
	has bit value 01 or decimal value 1.
	This policy prohibits direct peering and will always
	route through the source's 6bed4router.</t>
<t hangText="Presumptious Peering">
	has bit value 10 or decimal value 2.
	At the expense of reliability, this policy tries direct
	peering for a few seconds.  If reliability is not achieved
	within these seconds, it falls back to the same behaviour
	as Proper Peering, which can also route through the
	6bed4router.  Until that fallback however, traffic may
	be lost.</t>
<t hangText="Persistent Peering">
	has bit value 11 or decimal value 3.
	At the expense of reliability, this policy tries direct
	peering for a few seconds.  If reliability is not achieved
	within these seconds, it persists in this behaviour but
	will report errors, either with return values or through
	occasional ICMPv6 errors.  This policy is the most likely
	to drop traffic.</t>
</list>
These values can be chosen on a frame-by-frame basis without
damage to the logic that learns about the reliability of direct
peering.  Applications being aware of the meaning in a protocol
of each frame, may choose to use less reliable delivery modes
for application-specific purposes.</t>

</section> <!-- peerpol -->


<section title="Reliable Peering" anchor="reliable">

<t>Given the nature of NAPT, there can be no completely
reliable peering system without a fallback to a services
that bounces traffic.  This is why a 6bed4 network needs
the fallback option of a 6bed4router to offer reliable
routing.  When NAPT is enhanced with port forwarding,
this situation can be changed, and some applications may
implement so many alternative routing options that full
reliability might be waived.  This is why special
situations might be created to work reliably without a
6bed4router.  However, when 6bed4 is built into an
application that should "just work", it does need the
fallback 6bed4router to be reliable.</t>

<t>The 6bed4 network can reliably switch to direct peering
after a successful peering handshake.  This is a deductive
approach to NAPT traversal, and is achieved simply by trying
direct peering and observing if it arrives.  The lesson taken
from prior inductive approaches <xref target="RFC4380"/>
founded on classification of NAPT <xref target="RFC3489"/>
was that such an approach can easily misclassify NAPT
behaviour, ensuing in brittle IPv6 connectivity.</t>

<t>The decuction in 6bed4 is mostly through properties of
UDP.  Specifically, the absense of a protocol identifier
disables interpretation of the protocol behaviour by NAPT,
unless bold assumptions are made on the basis of a port
number.  To be workable, a NAPT therefore must keep an
outward-sending UDP port open for response traffic.  For
some protocols, the response may come from other angles,
which suggests that Endpoint-Dependent Mapping is not
suitable for UDP, but this cannot be assumed in general.
A certain amount of acceptable silence until the given
connection closes can however be assumed, and it is
commonly suggested that this should be at least 30 seconds.
The only assumption made by 6bed4 is that these 30 seconds
are a reasonable default, but of course this MUST be a
setting that can be overridden by operators.  NAPT software
MUST NOT make any assumptions of passing 6bed4 on the
basis of the standard port TBD2 if it is to comply with
this specification.</t>


<section title="Reliable 6bed4router Uplinks" anchor="reliable.uplink">

<t>Given that NAPT can only handle 6bed4peer traffic
as generic UDP traffic, any outbound UDP traffic necessarily
keeps a hole open for reverse traffic over a reasonable
minimum time.  When more traffic is sent before this period
has passed, there is no basis for NAPT to assume that the
connection can be severed, causing a reset of the timeout
for the hole.</t>

<t>To allow reliable bidirectional traffic between a
6bed4peer and its 6bed4router, it therefore initiates
with a Router Solicitation, and then continues to send
Keepalive messages with no smaller separating delay than
the delay for UDP holes.</t>

<t>Keepalive messages need not make it to the 6bed4router
to be effective.  Their only need is to make it beyond the
last NAPT or firewall.  This can both help to offload a
6bed4router and to avoid that it detects the 6bed4peer
still being online; since the 6bed4router is stateless,
it has no use for this information.</t>

<t>The content of a Keepalive message can be the minimum
that counts as UDP traffic, according to NAPT and firewalls;
this is an empty UDP frame.</t>

<t>A 6bed4peer can keep up any number of 6bed4router uplinks,
and would send Keepalive messages to each of them.  This being
a resource, the application may have to indicate explicitly
what uplinks are considered to be useful (or a trivial setup
such as a single uplink might be applied).</t>

</section> <!-- reliable.uplink -->

<section title="Probing for Direct Peering" anchor="reliable.probes">

<t>When choosing how to forward an IPv6 frame, a 6bed4peer
may consider direct routing, but refrain from it on account
of reliable considerations.  These are good moments to start
working towards direct routing.  Other moments are when a
6bed4peer forces direct peering through the Presumptious
and Persistent Peering Policies.</t>

<t>While working towards direct routing, a few attempts to
connect directly are made, by sending a Probe message if
no direct traffic is sent at the same time.  Probes are
the smallest possible UDP frame, so an empty UDP message.
They differ from Keepalives because their reach is not
constrained but the message is sent with the intention of
arriving at the remote 6bed4peer.  The destination IPv4
address and UDP port are taken from the bottom half of the
destination IPv6 address, which is only permitted for
addresses known to be bound by the 6bed4 network.</t>

<t>When a Probe arrives on a 6bed4peer, it cannot be
considered an IPv6 frame.  It is however detected as an
incoming UDP frame from a given IPv4 address and UDP port.
This identifies a remote peer that appears to be able to
make its way to the UDP socket, all the way through the
NAPT and firewalls at the destination end.</t>

</section> <!-- reliable.probes -->

<section title="Sending and Receiving the Seen Flag" anchor="reliable.seen">

<t>When a Probe arrives at a 6bed4peer, it MUST look if
the sending IPv4 address and UDP port have recently
received any traffic.  If so, the Probe will be processed
into a timer/state product.</t>

<t>Starting with the time of arrival, a hole can be reliably
assumed to be open in local NAPT, and that it remains open
for 30 seconds (or a locally overridden timeout) after the
last direct send to that remote, even if it was just a Probe
or Keepalive.</t>

<t>The time for the open hole is subdivided as follows:
<list style="symbols">
<t>1 second accounts for a message delay in both directions;</t>
<t>27 seconds account for the time that the remote peer may send directly;</t>
<t>the remaining time allows informing the other side that a Probe arrived.</t>
</list>
when a NAPT hole is assumed to be open for 30 seconds, then this
remaining time amounts to 2 seconds.  This time period, added to
the time of the last message sent to that remote, indicates a
period in which the Seen flag can be sent to the remote.  The
remaining time may be negative, in which case the Sent flag is
never sent to the remote.  When the local NAPT holes are set to
be open for longer periods, then the Seen flag is sent
correspondingly longer.</t>

<t>The Seen flag can be set in any Traffic Class that adheres
to the format for the 6bed4 network.  It does not matter if it
is relayed through one or two 6bed4routers, because it informs
about the direct connectivity between terminating 6bed4peers,
whose IPv4 address and UDP port must occur in the bottom half
of addresses if direct peering is to be considered at all.</t>

<t>It is an event when the Seen flag arrives from a 6bed4peer,
even from a 6bed4router, when it occurs in a Traffic Class that
adheres to the format for the 6bed4 network.  In case of this
event, the destination 6bed4peer may conclude that it can use
direct peering to the remote 6bed4peer for 27 seconds after
arrival of the Seen flag.  In active direct peering connections,
the Seen flag is likely to be present on most frames, causing
the regular reset of the 27-second timer.</t>

</section> <!-- reliable.seen -->

<section title="Peer NAPT State" anchor="reliable.pns">

<t>Every 6bed4peer keeps some state for its remote peers.
In contrast, the 6bed4router is a simple stateless process.
The state kept per remote peer is known as Peer NAPT State,
and is indexed by the IPv4 address and UDP port for the
remote peer.</t>

<t>The information kept for each remote peer consists of:
<list style="symbols">
<t>A current state and related timeout</t>
<t>A time for the last message sent</t>
<t>A time for the last message sent directly</t>
<t>A time until which the Seen flag is reported</t>
<t>A /64 or /114 prefix for local address binding (once known)</t>
</list>
There is no explicit time until which direct peering is
possible; this is instead derived from the current state.</t>

<t>This information differs from 6bed4router state, which
minimally requires just a /114 prefix and a timer until
the next Keepalive needs to be sent.  If so desired, the
Keepalive timer can be reset when a message is sent to the
6bed4router without risking to reduce reliability.</t>

</section> <!-- reliable.pns -->

<section title="State/Timer Diagram" anchor="reliable.std">

<t>The Peer NAPT State for a 6bed4peer follows the following
state diagram with default progression timeouts to administer
sender state:</t>

<figure><!-- <preamble>Sender State for a 6bed4peer</preamble> -->
<artwork>
<![CDATA[
                First.Send
                   |
                   V
                    INIT --1s--> INIT --1s-->.<------+
                    |            |           |       |
                    V            V           |       |
Seen.Flag         Probe        Probe         |      25s
    |                                        |       |
    V                                        V       |
     PEER---25s---> POLL --1s--> POLL --1s--> FAIL --+
                    |            |            |
                    V            V            V
                  Probe        Probe        Probe
]]>
</artwork>
</figure>

<t>This section describes the flow of this state/timer
diagram for the Proper Peering, which is the default
peering policy.  The next section describes the
modifications for the other peering policies.</t>

<t>The transitions marked 1s and 25s represent a
default transition to occur after 1 and 25 seconds in
the state, respectively.  Timeouts for NAPT holes
below 28 seconds MAY be rejected by a 6bed4peer; if
not, it MUST split the 25 second delays into values
less that the NAPT hole timeout and send Keepalives
at the extra points.  The total time MUST however
be kept at 25 seconds.</t>

<t>First.Send marks the entry point to the diagram,
used when initiating new Peer NAPT State for a remote
6bed4peer that had no such state managed yet.  When
entering FAIL state after a reasonable period with
no traffic sent to the remote peer, the Peer NAPT State
may be removed from administration.  What counts as a
"reasonable period" may be locally selected, but would
normally be in the range of tens of seconds.</t>

<t>Seen.Flag marks the point of reset of the state
when a Seen flag is set for traffic from this remote.
When connections are actively used, this flag would
occur on most frames, causing repeated resets of this
state diagram.</t>

<t>Probe marks the side-effect of sending a Probe upon
entry of a state.  The intention of the Probe is to
open a hole in outgoing NAPT and, at the same time, to
reach the remote peer directly and trigger the return
of a Seen flag.</t>

<t>The states in the diagram should be read as follows:
<list style="hanging">
<t hangText="INIT">
	marks the intention to work towards reliable
	direct peering.  A total of 3 Probes is sent
	to allow reasonable opportunity for the remote
	peer to detect it and send a Seen flag.</t>
<t hangText="PEER">
	marks reliably direct peering for a duration
	of 27 seconds (continued into POLL states).
	Having established in hole in local NAPT, no
	need for further Probes exists.</t>
<t hangText="POLL">
	still marks reliable direct peering, but also
	starts to send Probes because the hole in NAPT
	is assumed to be timing out soon.  The Probes
	are hoped to trigger new Seen flags, and are
	especially useful during one-directional
	transmissions.  However, when no traffic is
	passed at all there is nothing to carry the
	Seen flag, and the state diagram continues.</t>
<t hangText="FAIL">
	marks durable failure to cause a Seen flag to be
	returned from the remote peer.  This does not
	imply that the hole in NAPT towards that peer
	has been closed however; with 25 seconds between
	Probes, the hole would be kept open.  TODO:SETTING.
	Because Probes have no IPv6 header, there is no
	vessel for Seen flags, so connections are setup
	to close after a reasonable time of inactivity.</t>
</list></t>

</section> <!-- reliable.std -->

<section title="Differentiation through Peering Policies" anchor="reliable.peerpol">

<t>When a Traffic Class passes into and over the 6bed4 network,
and its format is that defined for the 6bed4 network, then it
may specify a peering policy.  In other cases, the default
peering policy applies, which is Proper Peering.</t>

<t>Peering Policies define how the choice between direct
peering and the source's 6bed4router is made:
<list style="hanging">
<t hangText="Proper Peering">
	defines the default behaviour as described in the
	previous paragram.</t>
<t hangText="Prohibited Peering">
	does not interact with Peer NAPT State or its
	State/Timer diagram.  Instead, traffic is always
	forwarded to the source's 6bed4router.</t>
<t hangText="Presumptious Peering">
	forces direct peering during the INIT states,
	but has the default behaviour in all other states.
	When the frame causes creation of Peer NAT State,
	the First.Send entry point is used, but the first
	Probe MAY be dropped because the frame causing it
	takes its place.</t>
<t hangText="Persistent Peering">
	forces direct peering in all states, but triggers
	errors instead of sending while residing in the
	FAIL state.</t>
</list></t>

<t>There is only one Peer NAPT State for a given remote peer;
this same diagram applies to all the peering policies, and
may be modified by it.  This allows traffic from a variety
of peering policies and a variety of connections to share
one knowledge base about direct peering.</t>

</section> <!-- reliable.peerpol -->

<section title="Bindable Local Prefix" anchor="reliable.binding">

<t>The Peer NAPT State holds a prefix, which is either the
unspecified address 0::0, a /64 prefix followed by 64 zeroed
bits, or a /114 prefix.</t>

<t>The initial state depends on the purpose; when a 6bed4peer
is contacted from an already-used source IPv6 prefix, then the
full /114 may be copied to it.  When initiating the contact
through a Router Solicitation to the remote 6bed4peer, it is
set to a /64 prefix to be shared, or to 0::0 if the prefix of
the remote 6bed4peer is to be assumed.</t>

<t>Upon arrival of an initial Router Advertisement from a
remote 6bed4peer, the /64 in the prefix is only updated when
it was 0::0; the following IPv4 address and UDP port in the
bottom half are always copied.  The last 14 bits with the lanid
are left zero.</t>

<t>Until the /114 prefix is complete, it is not possible to
bind a local address for traffic to the remote 6bed4peer,
let alone use it as a source address.  Only after the /114
prefix is known is it possible to select lanid values to
complete the IPv6 address.</t>

<t>After binding has occurred, a corrective Router Advertisement
may overwrite the IPv4 address and UDP port in the bottom half
of this binding prefix.  This marks a change, and any further
attempts to send to this remote peer from a previously bound
source IPv6 address with different IPv4 address and UDP port in
its bottom half are rejected by the 6bed4peer.  TODO:CODE</t>

<t>This undesirable situation blocks further direct peering and
requires a fallback to the 6bed4router, whose connection is kept
open through Keepalives.  The same approach can only work between
6bed4peers when both send Keepalives to each other, but this may
be wasteful in many scenarios, especially when normal traffic
flows regularly.  Also note that what worked for setting up
direct peering once is likely to work again later.</t>

</section> <!-- reliable.binding -->

<section title="Benefiting from Adaptive Flags" anchor="reliable.adaptive">

<t>The 6bed4 network is concerned with routing and peering
policy; this is used by applications, whose logic may be so
courteous that it does not matter if a locally bound address
changes.  In terms of the Socket API this would be the case
when neither bind() nor getsockname() are ever called.</t>

<t>Such ambivalence to the locally bound address can be a
benefit when NAPT mappings alter on a given connection.
It may help the number of direct peering successes to
signal that such an address change does not matter to the
application logic.  To this end, the Adaptive flag can be
set in frames submitted through a 6bed4peer, at the same
time as the desired Peering Policy.</t>

<t>When this flag is set, the behaviour in case of a mismatched
prefix for the remote peer is not to reject the traffic,
but instead to substitute the IPv4 address and UDP port
in the source IPv6 address of a frame; the /64 prefix should
match as always, and the lanid is not altered.</t>

<t>The address change is not reversed in the destination
IPv6 address of reply traffic.  This means that the
application would receive the altered address.  If this
could otherwise lead to confusion, the application might
choose to match reply traffic on the basis of a unique
lanid or a random Flow Label.</t>

<t>It is up to the application if this is possible, and
in which frames sent.  The safe default is to not allow
Adaptive source IPv6 addresses, but as long as it is
usually beneficial to set the Adaptive flag whenever it
is of no concern to application logic.</t>

</section> <!-- reliable.adaptive -->

</section> <!-- reliable -->


<section title="Global Routing of TBD1::/32" anchor="global">

<t>TODO: SOLVE A FILTER ON AUTHORITATIVE GATEWAY ROUTERS</t>

<t>HINTS FILE OPTION: Distribute the IPv4 addresses of gateway routers as part of the 6bed4router software, as is done for DNS root name servers.</t>

<t>DNS OPTION: Define 32.gateway.6bed4.net to hold /32 gateways, and perhaps &lt;IPv4/16&gt;.48.gateway.6bed4.net to hold /48 gateways.  These gateways are trusted by 6bed4routers.  The only thing these gateways do is to relay native IPv6 prefix TBD1::/32 from/to the 6bed4 network.  The IPv4/UDP is always that of the 6bed4router and the standard UDP port TBD2.</t>

<t>6TO4 OPTION??? Compare to https://labs.ripe.net/Members/emileaben/6to4-why-is-it-so-bad -- the main problem of 6to4 is firewalls not being setup for it, especially -- https://labs.ripe.net/Members/emileaben/6to4-how-bad-is-it-really -- if it is pushed through without asking users.  Note that a 6bed4peer may also run on a LAN, but only announces an address prefix when Router Solicitation responds.  The 6bed4router should however route properly... which is more easily established when it integrates into a router device where it has access to external interfaces and/or firewall rules.  Given that, even using 2002::/16 instead of TBD1::/32 and routing backend traffic over proto-41 might be an option?  But it has fallen in disgrace, even if only the anycast/unicast mixup of router setups appears to have been a cause and anycast was deprecated for 6to4.  Still, there is the issue of firewall traversal (that we solve by demanding a public IPv4 address and fixed UDP port for 6bed4routers).</t>

</section> <!-- global -->



<!-- OLD OLD OLD

<section title="Wire Format of 6bed4 Frames" anchor="wireformat">

<t>Since 6bed4 embedding supports general IPv6 traffic, it provides a
well-defined form for carrying around ICMPv6 messages,
including Neighbor Discovery messages.  These are actively used to
negotiate with 6bed4 Peers.  Router Solicitation and Advertisement
are used to determine a Public IPv6 Address;
Neighbor Solicitation and Advertisement are used to test and confirm if a
remote 6bed4 Peer can be reached at the Direct 6bed4 Address.</t>

<t>Router Advertisements in 6bed4 Frames announce /114 prefixes.
This leaves 14 bits that can be used locally to distinguish hosts under
the same prefix, possibly managed through static assignment and/or DHCPv6.
Note that the completion with all zero bits indicates the router <xref target="RFC4291"/>,
or more precisely, the 6bed4 Server that is the sender of the Router Advertisement.</t>

</section>


<section title="6bed4-Prefixed Address Format" anchor="addressformat">

<t>A 6bed4 Address is a concept that does not occur directly on the
wire; it is a pair of an IPv4 address and a UDP port.
This information may be binary represented as drawn below, showing
the address followed by the port, each in network byte order.</t>

<figure>< !- - <preamble>Conceptual Representation of a 6bed4 Address:</preamble> - - >
<artwork>
+- - - - - - - -+- - - -  - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -+
| IPv4.H | IPv4.h | IPv4.l | IPv4.L | UDP.H  | UDP.L  |
+- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -+
    8        8        8        8        8        8
</artwork>
</figure>

<t>In contrast with this pair, 6bed4-Prefixed Address actually occur
on the wire.  They contain at least a Fallback 6bed4 Address;
furthermore, somewhat dependent on a few flags
discussed below, this on-wire address usually holds a
Direct 6bed4 Address as well.</t>

<t>In places where link-scoped addresses <xref target="RFC4291"/> are used, they look like
a standard fe80::/10 prefix followed by zero-bit padding and ending in
the six bytes IPv4.H, IPv4.h, IPv4.l, IPv4.L, UDP.H and UDP.L.</t>

<t>The representation of the Fallback 6bed4 Address relies on the
knowledge that 6bed4 Servers run on the standard UDP port TBD2.
This information is not mentioned in the 6bed4-Prefixed Address, but
the IPv4 address is completely shown in the top 64 bits of the
6bed4-Prefixed Address.  The part "Fallback 6bed4" in the figure
below is filled with:
<list style="symbols">
<t>The four bytes IPv4.H, IPv4.h, IPv4.l and IPv4.L.</t>
</list>
</t>

<t>Assuming it is there, the representation of the Direct 6bed4 Address
it goes into the lower half of
the 6bed4-Prefixed Address, but it must respect the two bits of
the EUI-64 interface identifier (Section 2.5.1 of <xref target="RFC4291"/>).
The bits from the Direct 6bed4 Address that would otherwise be
put in those bit positions are
placed behind the rest of the Direct 6bed4 Address.  The resulting
bit sequence named "Direct 6bed4 Address" in the figure below is:
<list style="symbols">
<t>The highest six bits of IPv4.H;</t>
<t>A bit value 0 to indicate that the address is not made globally unique through the use of an Organizationally Unique Identifier <xref target="IEEE-EUI64"/> <xref target="RFC2372"/>;</t>
<t>A bit value 0 to indicate that the address does not address a group <xref target="IEEE-EUI64"/> <xref target="RFC2372"/>;</t>
<t>The three bytes IPv4.h, IPv4.l and IPv4.L;</t>
<t>The two bytes UDP.H and UDP.L;</t>
<t>The lowest two bits of IPv4.H.</t>
</list>
</t>

<t>The last part of the 6bed4-Prefixed Address concerns the 14 bits that
follow after the /114 prefix from the Router Advertisement.  This part is left
to the local 6bed4 endpoint to fill.  As is standardised,
the continuation with all zero bits is reserved
(Section 2.6.1 of <xref target="RFC4291"/>) for the
on-link address of the router that sent the prefix.  This part is
named "lanip" in the figure below.</t>

<t>Combining these fragments, the general format of a 6bed4-Prefixed
address that can be embedded as 6bed4 is as follows:
<figure>< !- - <preamble>6bed4-Prefixed IPv6 address format:</preamble> - - >
<artwork>
 0               32              64                       114    128
 +- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+
 |      TBD1     | Fallback 6bed4|  Direct 6bed4 Address  | lanip|
 +- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+- - - - - - -+
 &lt;- - - - - - - - - - - - - - - - - - - - - /114 prefix - - - - - - - - - - - - - - - - - - - - - -&gt;
</artwork>
</figure>
</t>

<t>The well-known TBD1::/32 prefix is important; it enables routing software to
recognise this format in IPv6 addresses, and suffices to support
global routing to the 6bed4 endpoint specified in this format of IPv6
destination address.  More on global routing follows in
<xref target="globalrouting"/>; for now, note
how it takes a /32+32 Prefix to describe the route to a particular
6bed4 Server; however, when the IPv4 address of this server is contained in
a /16 prefix it is possible to publish a /32+16 Prefix, which is rather
common.</t>

<t>The prefix TBD1::/32 and port TBD2 are only reserved for a period of ten years,
starting at the date of publication of this specification.  Implementations
that are aware of time MUST NOT implement 6bed4 after the final date; an
extension of the final date is only possible through an updating RFC that
at least passes through Expert Review for both allocated resources.
The ten-year period was selected to support five years for new applications
to roll out IPv6 and even IPv6-only applications to be built on top of 6bed4,
and another five years for the use of 6bed4 to cease
to exist and omnipresent, native IPv6 to replace it.</t>


<section title="Invitations for Direct Connections">

<t>One special condition in a 6bed4-Prefixed Address can be treated as
an invitation for Direct 6bed4 Connections, namely when the Fallback and
Direct 6bed4 Address are the same.  In terms of the address format, this
means that the IPv4 addresses are the same, and that the UDP port
in the Direct 6bed4 Address is the 6bed4 standard port TBD2.</t>

<t>6bed4 Peers can announce this form of IPv6 Address when they are able
to receive 6bed4 Frames from anyone on their Direct 6bed4 Address; for this
reason, this special format can be used to cause Direct 6bed4 Connections
to this 6bed4-Prefixed Address; details are given in <xref target="invitedopportunisticpeering"/>.</t>

</section>

<section title="Interpretation of EUI-64 flag bits" anchor="eui64flagbits">

<t>The 6bed4-Prefixed address format specifies that the Universal/Local bit
is set to Local, and that the Individual/Group bit is set to Inidividual
<xref target="IEEE-EUI64"/>.  In the lower half of IPv6 addresses <xref target="RFC2372"/>,
both of these choices are represented with bit value 0.</t>

<t>Should a 6bed4-Prefixed Address set either or both these bits to 1, 
then this specification treats the entire bottom half of such remote
peer addresses as an opaque bit array; local extensions to this
specification are possible, but no interpretation is defined herein.
If the bottom half is
treated as an opaque bit array, a Direct 6bed4 Address MUST NOT be
retrieved from the 6bed-Prefixed Address.</t>

<t>What remains in such situations is to address the Fallback 6bed4 Address
when sending traffic.  Effectively, this leaves the local
interpretation of the bottom half of the 6bed4-Prefixed Address to the
Fallback 6bed4 Server.  This leaves room for various
interpretations and (local) extensions without impairing routability.</t>

<t>One suggested extension is to support
Stateless Address Autoconfiguration <xref target="RFC4862"/> 
on a local network segment, based on a 6bed4 Server that handles port TBD2 for a
Public IPv4 address.  Such extensions MUST suppress Public IPv6 Addresses
specified as Local and Individual, which could arise from manually specified
addresses or from privacy extensions <xref target="RFC4941"/>.  Permitting
such addresses to occur as Public IPv6 Addresses would be misinterpreted
to contain a Direct 6bed4 Address, and would therefore lead to routing
problems.</t>

<t>Another suggested extension is to support multicast destinations with a
6bed4-Prefixed Address that has the Individual/Group bit set to 1.  The
Fallback 6bed4 Server mentioned in the top half can forward traffic over sparse
or dense multicast networks, based on local policy; one example local
policy would route to all nodes on a locally connected network; another
example local policy would route to all nodes that have explicitly
subscribed to a particular multicast channel.</t>

</section>

</section>


<section title="6bed4 Infrastructure and Protocol Overview" anchor="networkinfra">

<t>This specification does not refer to parts of the 6bed4 Infrastructure
as tunnel clients and tunnel servers, but rather as 6bed4 Peers and
6bed4 Servers.  This reflects the intention of making the endpoints,
or peers, use Direct UDP/IPv4 Streams as their preferred transport for
6bed4 Connections.</t>

<t>The purposes of a 6bed4 Server are to provide information
about the Public IPv6 Address to 6bed4 Peers, and to permit fallback to
Fallback 6bed4 Streams as a transport mechanism between 6bed4 Peers
for which Direct UDP/IPv4 Streams are not
feasible.  Finally, the 6bed4 Server is needed to connect a host that
can only do 6bed4 to one that can only do Native IPv6 Addresses; precautions
to avoid that situation wherever possible follow.</t>

<t>Every 6bed4 Peer is configured with the address of a Fallback 6bed4 Server.
Given the strong pressure towards Direct UDP/IPv4 Streams, the traffic to
a Fallback 6bed4 Server is very limited, and so offering this kind of
service is considered very scalable.</t>

<t>To be reachable to the outside world on a Public IPv6 Address,
a 6bed4 Peer sends a Router Solicitation to a 6bed4 Server, and receives
a Router Advertisement with a /114 prefix in response.
As shown in
<xref target="wireformat"/>, the returned prefix includes both the
Fallback and Direct 6bed4 Addresses, and leaves some
room for local address assignment to serve a potential desire to
route to a local network.
It is then the local 6bed4 Peer's task to keep open
the UDP/IPv4 Stream to the 6bed4 Server, so as to ensure that
the IPv6 address remains constant.  If it were to change, then the
server would respond to sent traffic with a new Router Advertisement,
offering a new /114 prefix and retracting the previous one.  This
leads to an address change, which is usually avoided by sending regular
keepalive messages.</t>

<t>When initiating a new 6bed4 Connection, in other words when first
contacting a remote 6bed4 Peer, it is also possible to send
a Router Solicitation to the Fallback 6bed4 Address found in the
remote 6bed4 Address.  This results in an alternate 6bed4-Prefixed Address
that can be setup locally for that contact attempt, avoiding trapezium-shaped
routing between 6bed4 Peers.  This specification ensures that this mechanism
will always work, but a similar responsibility to keep this link to the
remote 6bed4 Server open falls upon the local system.</t>

<t>Finally, for the most agressive approach towards peer-to-peer
connections, it is even possible to send the Router Solicitation
to the Direct 6bed4 Address of the targeted peer.  Peers who intend
to invite this method can ensure that the external port TBD2 leads
directly to them, and then copy their Direct 6bed4 Address in the
Fallback 6bed4 Address.  This would bypass a Fallback 6bed4 Server and 
lead to true peer-to-peer connectivity.  It should be noted
that it is not safe in the most general case to only try the
Direct 6bed4 Address if certainty of the connection is required;
the Fallback 6bed4 Address is a necessary ingredient to achieve
certainty.  Using the same Direct and Fallback 6bed4 Adress in
a 6bed4-Prefixed address indicates that the certainty exists
that no separate Fallback server is needed.</t>

<t>At any time before or during communication with a 6bed4 Peer through a
6bed4 Server, it is possible to try using a Direct UDP/IPv4 Stream
by sending
a Neighbor Solicitation from a local Direct 6bed4 Address to the peer's
Direct 6bed4 Address, and observing if it is matched by a
Neighbor Advertisement over the opposite path.  In this, "matched" means
that it MUST be certain that the Neighbor Advertisement was not sent in
response to a Neighbor Solicition that went out over another channel.
<xref target="opportunism"/> presents a few alternatives to this
standard method.</t>

<t>When such direct requests lead to matching direct responses, then
it is safe to assume that a Direct UDP/IPv4 Stream is possible
between the 6bed4 Peers, at least
for some time following.  This is because UDP/IPv4 has worked in both
directions,
and the fact that it contained ICMPv6 cannot be inferred by the
intermediate NAT routers or firewalls because the UDP header does not
tag its contents.  To ensure that this assumption continues to hold,
firewalls and NAT routers MUST NOT interpret frames from and to the
standard 6bed4 port TBD2 as 6bed4 Frames, but simply treat them
as any other UDP traffic.</t>

<t>The knowledge that a remote 6bed4 Address can be reached over a
certain UDP/IPv4 Stream MUST NOT be assumed to also apply to
communication with any other IPv6 Address.
This is vital, as it evades the trap of making inductive assumptions
about the behaviour of NAT or firewalls.  See
<xref target="nattraversal"/> for details of the deductive approach of
6bed4 regarding regarding NAT and firewalls.</t>

<t>It is common for IPv6 hosts to have multiple IPv6 addresses, and
so the question arises which local and remote addresses to use.  This has been
answered in <xref target="RFC6724"/>.
In relation to 6bed4, native-to-native traffic MUST precede
6bed4-to-6bed4.  In addition, 6bed4-to-6bed4 SHOULD be preferred over either
native-to-6bed4 and 6bed4-to-native, because it is more desirable to use
a Direct UDP/IPv4 Stream than a Fallback UDP/IPv4 Stream through a
6bed4 Server.  Every 6bed4 Server is ultimately a shared resource and
thereby a potential bottle neck for routing efficiency.  This choice helps
to offload 6bed4 Servers, and to improve their scalability.</t>

<t>In addition to this optimisation, higher-layer applications MAY
also incorporate knowledge of 6bed4; for instance, a SIP endpoint <xref target="RFC3261"/> could observe
a remote peer's 6bed4-Prefixed Address and offer media exchange over a 6bed4-Prefixed Address
instead of a Native IPv6 Address, once more with the intention to offload
the shared resource of a 6bed4 Server, as well as to lower roundtrip delays
and jitter.  Such a clever SIP server could even aim to construct a more optimal 6bed4-Prefixed Address for the connection using the techniques mentioned in <xref target="sipopportunisticpeering"/>.</t>

</section>


<section title="NAT and Firewall Traversal" anchor="nattraversal">

<t>There is a wide variety of NAT router implementations, usually with
subtly different characteristics.  A similar thing applies to firewalls.
This means that any approach to peering through NAT and firewalls that
is to work everywhere must be founded on deductive reasoning-from-facts,
and not induce information from an incomplete survey of NAT routers and
firewalls.  Specifically, STUN <xref target="RFC3489"/>
used to make such inductions which were later relativated (Section 14.3 <xref target="RFC5389"/>).
An IPv6 tunneling mechanism based on this work <xref target="RFC4380"/> has indeed shown to
not work in general <xref target="POTAROO"/>.</t>

<t>Network components that alter
the contents of UDP frames have been reported <xref target="RFC4380"/> but are downright
broken.  They may need to be replaced before 6bed4 can function.</t>

<t>This specification assumes that outgoing UDP is supported.  There are
places where dramatically constrained Internet connectivity is offered,
but this is not what constitutes Internet according to the IETF.  To
mend such hacked networks, equally hacked approaches may be built in
extension to this specification, such as
a fallback to TCP, or perhaps even WebSockets <xref target="RFC6455"/>.
This specification does not detail such alternatives.</t>

<t>Except for local keepalive timing, nothing in 6bed4 makes assumptions
about the behaviour of NAT beyond basic support for UDP in general.
Specifically, there is no dependency on a behavioural classification of NAT
routers or firewalls.  Instead, 6bed4 simply tries if IPv6 traffic
between peers is possible by sending a frame directly to a peer
and matching it with a return frame.  In case of success, it is assumed
that bidirectional direct peering is possible.</t>

<t>6bed4 Connections are carried over
an UDP/IPv4 stream, and UDP has no content tagging, so a NAT router
cannot treat this test exchange in any way different from "normal" UDP traffic.</t>

<t>When sending UDP out through a NAT router, it will usually substitute
the source IPv4 address and UDP port with an external IPv4 address and
UDP port.  For UDP protocols to behave normally in the presence of this
translation, the NAT implementation is held to apply the same
substitution
when future frames are sent over the same UDP/IPv4 Stream, so a sustained mapping
between internal and external IPv4 address and UDP port can safely be
assumed.</t>

<t>To find an entry in this mapping, the
NAT router can select values from the source and destination IPv4
addresses and UDP ports, but as long
as all these values match, the same UDP/IPv4 stream is recognised and
the same mapping must be applied.  There is no implementation freedom
here; the opposite substitution is the only way to support UDP in general.</t>

<t>Firewalls have a similar mapping, albeit not for substituting an
address and port, but to recognise if traffic has been sent out over
a UDP/IPv4 stream.  Other than this difference, it generally behaves
under the same constraints as a mapping in a NAT router.</t>

<t>To handle all mappings that are possible, 6bed4 makes no assumption about
sharing the same mapping for different UDP/IPv4 Streams; a Public IPv4
Address and UDP Port may be the same for two remote peers, or they
may differ.  As far as 6bed4 concerns, they may be separately administered
mappings.  And if they happen to overlap then it is still safe to treat
them separately, as the protocol components are idempotent.</t>

<t>UDP has no formal end marker for a UDP/IPv4 Stream, and it is not
common in middle boxes to poll locally if the connection is
still open, so the common approach in routers
is to guess when a stream has ended.  It is assumed
by this specification that a mapping is kept active for a minimum time,
and revived at least when traffic is sent out along the stream, as that
is the only thing on which an implementation can base such
revivals without making UDP
insecure.  To overcome timeouts on such mappings, a keepalive mechanism
is needed in a number
of places, and the timer triggering that mechanism must be a setting
that the end user can influence.  Experiments <xref target="RFC4380"/> have shown that
a default setting of 30 seconds is quite likely to work.  To avoid
being presumptious, implementations SHOULD permit user configuration
of this timeout value.</t>

<t>Timeouts are related to the local network infrastructure, so the
local 6bed4 Peer is the proper place for making such settings.  It
is also possible for these local settings to include a TTL for the
keepalive messages; there is no need for keepalives to reach the
remote endpoint, but rather these messages should get past all the
local middle boxes and out on the public Internet, in order to keep
an UDP/IPv4 Stream open.</t>

</section>

<section title="Filtering 6bed4 Traffic" anchor="filtering">

<t>Any tunnel should guard against being abused for claims
on addresses "inside" the tunnel based on "outside" clients
that should not be able to make such claims.
In the case of 6bed4, this means that the 6bed4 Address from
which a 6bed4 Frame arrives must match with the Sender IPv6
Address.</t>

<t>When a filter rejects a 6bed4 Frame on account of a mismatch
between the Source 6bed4 Address and the suggested IPv6 address,
it should respond with a Router Advertisement that retracts the
/114 prefix used in the IPv6 address, and offers a new /114 prefix
that would have matched to replace it.</t>

<t>Both 6bed4 Servers and 6bed4 Peers MUST silently discard any
6bed4-embedded frame that is neither a proper IPv6 message nor
an RoHC-compressed packet; example conditions to implement that would be:
<list style="symbols">
<t>the embedded frame length is less than that of an IPv6 header</t>
<t>the embedded frame does not start with nibble 6, 14 or 15</t>
<t>the embedded frame length differs from the total IPv6 frame length</t>
<t>there are checksum errors in TCP, ICMPv6 or UDP headers</t>
</list>
</t>

<t>If the recipient is a 6bed4 Server, then the Source 6bed4 Address
of an acceptable 6bed4 Frame MUST match one of the following:
<list style="symbols">
<t>the Direct 6bed4 Address embedded in the Source 6bed4 Address;</t>
<t>the Fallback 6bed4 Address of a 6bed4 Server known to announce TBD1::/32, but only if the recipient's 6bed4 Address matches the Destination 6bed4 Address of the 6bed4 Frame.</t>
</list>
Note that 6bed4 Frames may occasionally travel through a router announced for TBD1::/32 but not when they are sent from a 6bed4-Prefixed Address, in which case it would have been forwarded to a 6bed4 Address.
</t>

<t>If the recipient is a 6bed4 Peer, then the Source 6bed4 Address
of an acceptable 6bed4 Frame MUST match one of the following:
<list style="symbols">
<t>the Direct 6bed4 Address embedded in the Source IPv6 Address, but this can only succeed when the Direct 6bed4 Address can be retrieved;</t>
<t>the Fallback 6bed4 Address embedded in the Source IPv6 Address.</t>
</list>
In addition, the Destination 6bed4 Address of an acceptable 6bed4 Frame
MUST match the following:
<list style="symbols">
<t>the Direct 6bed4 Address in the Desintation IPv6 Address, but this check also succeeds if it cannot be retrieved.</t>
</list>
Finally, the destination IPv6 address SHOULD be assigned by the
6bed4 Server set as the Fallback 6bed4 Address as part of the
destination IPv6 address.
</t>

<t>The situations in which a Direct 6bed4 Address cannot be retrieved
are specified in <xref target="eui64flagbits"/>.</t>

<t>A 6bed4 Server MAY apply additional filtering to limit its
use to a particular subset of 6bed4 Peers; for instance, the users
of an ISP or a commercial 6bed4 service.  To this end, it would
ensure that 6bed4 Frames are passed either from or to a Direct
6bed4 Address that is accepted.  This MUST NOT be done on a
6bed4 Server that announces routability for the TBD1::/32 prefix.</t>

<t>The only messages exempted from all aforementioned filtering
are Router Solicitation frames targeting a link-local IPv6 address,
and having their IPv6 Hop Limit set to 255.  Those messages receive
a Router Advertisement frame in reply, containing the /114 prefix
that matches the 6bed4 Address of the originator of the solicitation.
Even a limited-access 6bed4 Server
MUST welcome Router Solicitation from unaffiliated peers that intend
to avoid trapezium-shaped routing.</t>

</section>


<section title="Routing 6bed4 Traffic" anchor="globalrouting">

<t>In backbone networks, IPv6 connectivity providers exchange routes through the Border Gateway Protocol (BGP).  There is no standard for prefix lengths to support in BGP, so everyone makes their own filtering rules.  In practice [TODO:xref target="https://labs.ripe.net/Members/dbayer/visibility-of-prefix-lengths"] however, a /48 is a widely supported length, unlike anything that is longer.  The small percentage that does not support the /48 is usually capable of routing through a covering /32 IPv6 prefix.  The prudent approach to global routeability appears to be the combination of a /32+16 with a covering /32+0 prefix.</t>

<t>To advertise routing over an IPv4 range one MUST own it, so the announcement of a /32+16 Prefix is only possible for a 6bed4 Address that falls in a /16 prefix that is owned by the autonomous system that runs (or otherwise supports) the 6bed4 Server.  An exception is made for the /32+0 Prefix, which serves as a fallback routing facility.  This fallback range can be used as anycast, so this MAY be announced by any party implementing a 6bed4 Server.  What this means is that control over return traffic is only possible through announcement of the /32+16 Prefix, with a minute portion of the Internet still routing it through the /32+0 Prefix announcement.</t>

<t>Anyone announcing a /32+16 Prefix MAY also announce the /32+0 Prefix, which is TBD1::/32 itself.  Anyone announcing the /32+0 Prefix MUST respond to all 6bed4 traffic targeted at 6bed4 Server addresses outside locally administered IPv4 ranges by relaying such traffic to a suitable IPv6 router; to that end, it MUST endeavour to collect all routing announcements for /32+16 Prefixes.</t>

<t>Announced /32+16 Prefixes SHOULD be retracted during downtime of the 6bed4 service; announced /32 Prefixes MUST be retracted during downtime of the 6bed4 service.  It is advised to relay routing messages that establish these routes through the 6bed4 service, to the effect that service downtime implies route announcement retraction.  This would not normally interfere with intentions to setup redundant 6bed4 service.</t>


<section title="Network Endpoint Routing Options">

<t>Given the availability of /32+0 announcements, as an anycast service, it is possible for any node with a single IPv4 address and access to the 6bed4 port TBD2 to offer 6bed4 service.  The quality level of this service may be lower due to the dependency on the anycast range for more than just fallback routing.  Having said that, it does enable a model where an endpoint can run a 6bed4 service to cover  a local network.  In this case it is possible to use the local numbering scheme, as long as the respective bit in the EUI-64 address are set appropriately.</t>

</section>

</section>


<section title="Opportunistic Peering" anchor="opportunism">

<t>An explicit design goal of 6bed4 is to exploit Direct UDP/IPv4 Streams
between 6bed4 Peers.  This is achieved by simply trying an exchange
over UDP/IPv4 and relying on the uninterpreted transport of UDP payloads
to infer that the entire UDP/IPv4 stream must be possible if a single exchange
works bidirectionally.</t>

<t>It is vital for this mechanism that UDP/IPv4 Streams follow the same path in
both directions, at least inasfar as it passes through local middle boxes.
In practice, this is a fair assumption to make,
because it is generally safe to assume that
outgoing traffic in a UDP/IPv4 Stream keeps NAT router and firewalls
open for return traffic.
To ensure this, a 6bed4 Peer that receives direct traffic from a
remote peer that it would address through a 6bed4 Server MUST start
one of the following methods to attempt to setup direct peering.  In such cases,
it SHOULD not give up before it has tried the Neighbor Discovery method,
which is the only obliged method, but it MAY try other methods as well.</t>

<t>The one thing left to specify is how peering is initiated.  This
is done by one of the following methods to setup direct peering,
applied opportunistically.  This can basically be done at any time
deemed fitting, but it is suggested to employ some form of rate
limiting for opportunistic peering attempts.  A few useful places
to do this would be to send a Router Advertisement to a direct
6bed4 Address before sending it to its general 6bed4 Address; or
to send Neighbor Discovery sometime during the normal exchange;
or to do it during the setup of a TCP/IPv6 stream.</t>

<t>The following subsections introduce a general framework for
trying to setup direct peering.  It continues with a few concrete
examples, some of which must be implemented with 6bed4.  There
are certainly opportunities for other specific implementations
of the general opportunistic mechanism.</t>


<section title="Abstract Framework for Direct Peering" anchor="generalopportunisticpeering">

<t>The abstract concept of direct peering rests on sending a message directly to a Direct 6bed4 Peer, in an attempt to establish bidirectional contact.  The "official" version is to create a dedicated message exchange for this purpose, but many protocols could support the "trick" of trying a first message towards the Direct 6bed4 Address and, if this fails and higher-layer protocols decide to resend, to continue the exchange through the Fallback 6bed4 Address.  The latter approach is a slight abuse of the known-lossy nature of networks.</t>

<t>The abstract framework must be able to relate an incoming direct reply to a previously sent direct request, and distinguish it from requests sent through the Fallback 6bed4 Address.  This can be established with a nonce if a frame is generated specifically for the purposes of 6bed4 Peer detection; or if a higher protocol layer generates the message, then the time between the first send and a later re-send is the window during which the direct response is considered a reliable sign of bidirectional traffic.</t>


</section>

<section title="Neighbor-Discovery-based Direct Peering" anchor="neighboropportunisticpeering">

<t>One mechanism that MUST be implemented in all 6bed4 Peers is that of peering setup through Neighbor Discovery.  This involves a Neighbor Solictation generated by the 6bed4 Peer over a Direct UDP/IPv4 Stream, and receiving a reply in the form of a Neighbor Advertisement.  This is the standard reachability detection mechanism for IPv6.  The usual ICMPv6 requirement of a Hop Limit equal to 255 applies here, and is not invalidated by the multiple hops made in the underlying UDP/IPv4 transport.</t>

<t>In order to ensure that a response matches a request sent directly, as well as to thwart attemts to overtake traffic, a nonce following <xref target="RFC6496"/> MUST be sent as part of the Neighbor Solicitation.  A 6bed4 Peer MUST respond to Neighbor Solicitation with Hop Limit 255 and its own address information as destination with a Neighbor Advertisement with Hop Limit 255, and it MUST include any nonce it found in the Neighbor Solicitation.</t>

<t>A 6bed4 Peer wanting to initiate a Direct 6bed4 Connection may use this mechanism at any time; it is safe because it does not interfere with the actual data stream between the peers.  These internally generated Neighbor Discovery messages SHOULD NOT be sent via the 6bed4 Server.  Only when a direct Neighbor Solicitation results in a Neighbor Advertisement with the same nonce may the originator of the exchange conclude that a Direct 6bed4 Connection can be used.  The remote peer MUST NOT draw that conclusion from the same exchange, as it cannot be sure if the direct Neighbor Advertisement arrived.  Also in the interest of security, it should initiate its own exchange because it sees the presumably successful exchange as a hint that a Direct UDP/IPv4 is feasible.</t>

</section>

<section title="Routing-based Direct Peering" anchor="routeropportunisticpeering">

<t>Another mechanism that SHOULD be implemented in 6bed4 Peers, and that MUST be implemented in 6bed4 Servers, is responding to Router Discovery messages with the Hop Limit set to 255.  The response must be a Router Solicitation composed of the /114 prefix formed as defined in <xref target="addressformat"/>; the Fallback 6bed4 Address refers to the 6bed4 Server for the address, the Direct 6bed4 Address holds to the observed UDP port and IPv4 address of the sender of the Router Discovery message.  Any nonces included in the Router Discovery MUST be replicated in the Router Solicitation.  Furthermore, a 6bed4 Peer MUST include a nonce if it sends out a Router Discovery message.</t>

</section>

<section title="Invitation-based Direct Peering" anchor="invitedopportunisticpeering">

<t>The simplest possible form of opportunistic direct routing is when the 6bed4-Prefixed address of a remote peer has the same values set as its Fallback and Direct 6bed4 Address.  This means that the opportunistic route can be tried immediately, as the 6bed4 Server function requires accessibility over the standard UDP port TBD2 that is apparently also in use for Direct 6bed4 Connections.</t>

<t>Note that it is usually necessary to obtain a 6bed4-Prefixed Address to use for communication with such a party, so if no local IPv6 address with the same /64 as the remote peer's IPv6 address exists, then one should be requested from the remote peer through Router Solicitation.  This will inform the local peer how its public address looks to the inviting peer.</t>

</section>


<section title="TCP-based Direct Peering" anchor="tcpopportunisticpeering">

<t>This mechanism MAY be incorporated into 6bed4 implementations that run
TCP over 6bed4.  It piggy-backs on the SYN and ACK flags exchanged while
setting up a TCP connection to a remote 6bed4 Peer, and introduces peering
opportunistically and, quite possibly, without any exchanges with a
6bed4 Server for setting it up.</t>

<t>TCP-based peering is based on the SYN flag sent initially by a new
TCP connection being setup, and the ACK flag sent to acknowledge it.
Furthermore, it assumes that the TCP stack wil resend a failed first
SYN attempt.</t>

<t>Under this opportunistic scheme for direct route discovery,
the first SYN sent to a remote 6bed4 Peer would be sent to the
Direct 6bed4 Address of the remote peer; if it reports back with the
ACK flag set, then a direct connection was clearly possible.  If this
response does not arrive before the TCP-stack re-sends the SYN fame,
then this and further attempts are sent to the Fallback 6bed4 Address,
until further inspiration triggers another attempt at direct peering.</t>

<t>The endpoint information in TCP as well as window offsets are
used to recognise the SYN attempt, and later pairing the ACK to it.
This means that the conditions are available to establish with certainty that a
direct request has been answered with a direct response.</t>

<t>Note that this mechanism works in both directions; as the passive
side sends an ACK responds to a SYN request, it usually sends its own SYN flag in
hope of an ACK back from the active side.  This second exchange can
follow the same rules to detect bidirectional connectivity from the
other side.  Sending that first ACK along with the second SYN also
means that a first attempt is made from the passive side to establish
direct peering.  Receiving the second ACK on the passive side over
a direct connection before resending the second SYN through the
Fallback 6bed4 Address indicates to the passive side that it can
use a Direct UDP/IPv4 Stream.</t>

<t>This facility is useful for servers that have configured their
NAT and Firewalls to open a UDP port, so any direct contact attempts
are certain to succeed.  This can then be used to construct a fixed
6bed4 Address, which would be suitable for publication in DNS, perhaps
as an alternative to a Native IPv6 Address.</t>
< !- -WHAT?
Although the Invitations of <xref target="invitedopportunisticpeering"/>
are a special form of this approach, the TCP-based approach covers
many more situations.</t>
- - >

</section>


<section title="SCTP-based Direct Peering" anchor="sctpopportunisticpeering">

<t>The Opportunistic Peering method for SCTP <xref target="RFC4960"/> is a variation on the method
for TCP.  Note that SCTP does not have its usual acceptance problems when
used between 6bed4 Peers, because 6bed4 traffic is largely unfiltered and
tunnels through the NAT routers that currently tend to block this
protocol.</t>

<t>SCTP follows an association initiation protocol with four frames instead
of the three of TCP.  The last two may carry data chunks, but this would be
stored in a separate chunk, giving the network layer some freedom to
manipulate the frames if desired.</t>

<t>The advantage of four messages over three is that the first
chunk (INIT) can be sent first to the Direct 6bed4 Address, then to
the Fallback 6bed4 Address of the remote peer, which can then assume that
outgoing UDP traffic has opened a hole in NAT and Firewalls.  This means
that the chances of entry for a reply message are optimal.  
Therefore, the opportunistic method for SCTP relies not on the first,
but on the second to fourth messages for association initiation.</t>

<t>The INIT-ACK chunk counts as an opportunistic attempt from the remote to
the local peer when it arrives over the Direct UDP/IPv4 Stream; the COOKIE
chunk sent over the Direct UDP/IPv4 stream signals acceptance to the
remote peer and is at the same time an opportunistic attempt from the
local peer to the remote; the COOKIE ECHO chunk sent over the Direct UDP/IPv4
Stream signals acceptance to the local peer.</t>

<t>In short, new SCTP associations can send the first attempt of each of the
chunks for association initiation to the Direct 6bed4 Address of a peer.
With the exception of INIT, the arrival of a chunk over the Fallback
UDP/IPv4 Stream indicates that the SCTP association must continue through
the 6bed4 Server.</t>

</section>


<section title="SIP-supported Direct Peering" anchor="sipopportunisticpeering">

<t>Another example of opportunistic peering that can be advantageous for
a specific application is SIP <xref target="RFC3261"/>.  A SIP exchange consists of a request
and one or more responses.  The application software is well aware of
the distinction between those, and can prove useful to facilitate 6bed4
peering if it integrates with the network layers.</t>

<t>SIP messages, when sent over UDP, are prone to resends if a response
is not received for some time.  As a result, it is possible to first
attempt sending to the remote peer's Direct 6bed4 Address, and send
later retries to the Fallback 6bed4 Address.  As with TCP, it is possible
to treat as proof of direct peering any incoming direct responses between
the intial request and its re-sends through the Fallback 6bed4 Address.</t>

<t>The link between a SIP request and its response is easily made with
the identifying parts of the message; these are embedded in text and
would thus work best when the application integrates 6bed4 and this
opportunistic method for direct peering.  The message-identifying parts are
contained in the Call-ID header, the From header tag and optional To header tag.
In addition, the top Via header contains a branch parameter that
identifies the exchange.  All this is the knowledge domain of the
application, and embedding it into 6bed4 tunneling code would undermine
the separation of network layers.  What this indicates however, is that
an API between the 6bed4 stack and the application layer can provide
new benefits.</t>

</section>


</section>


<section title="Support for Robust Header Compression" anchor="rohc">

<t>The RoHC framework <xref target="RFC3095"/> makes use of repetitive and predictable patterns in headers to achieve header compression, and defines a robust protocol to agree on the possibilities for doing so.  At least two possible applications of 6bed4 make this compression desirable, namely a peer-to-peer carrier for RTP flows and a tunneling mechanism to gain access to IPv6 over mobile networks.  In support of these and other applications, 6bed4 incorporates support for RoHC between peers.  It does however acknowledge the possibility of a minimal implementation that understands just enough of RoHC to reliably reject it.  Requiring at least this minimal implementations means that negotiation of RoHC can be attempted between peers without loss of robustness.</t>

<t>The RoHC specification allows a number of predefined values for various settings.  These will not be negotiated by 6bed4, but are defined here for the general tunneling application.  Specific applications that embed the logic of 6bed4 for their own purposes have full control over both endpoints of a 6bed4 Connection and MAY therefore override these default choices.</t>

<t>
<list style="symbols">
<t>The CID value 0x00 is predefined for profile 0x0000, RoHC uncompressed traffic. Since this CID value is not explicitly sent as part of RoHC frames, traffic can be sent unchanged and still pass through an RoHC decompressor as it should;</t>

<t>Any RoHC-traffic besides uncompressed traffic is sent with the first nibble value 14 or 15, which is distinguishable from the start nibble 6 for IPv6 frames. RoHC defines a padding byte that could be used before any (future) byte that starts with another nibble than 14 or 15;</t>

<t>LARGE_CIDS is true, and MAX_CID is correspondingly set to 16383; CID value 0 MUST NOT be sent and CID values 1 to 15 inclusive MAY be represented in the short form; larger CID values MUST be represented in the longer form in 1 or 2 bytes; recipients of RoHC packets MUST be able to process both long and short CID forms;</t>

<t>The MRRU value is 1280;</t>

<t>It is advised to provide support for at least the profiles 0x0000, 0x0101, 0x0102, 0x0103, 0x0104 and 0x0006; these are ROHC uncompressed, RoHCv2 RTP, RoHCv2 UDP, RoHCv2 ESP, RoHCv2 IP, RoHC TCP.</t>

</list>
</t>

<t>RoHC can be very useful between 6bed4 Peers.  On a 6bed4 Server, the use of RoHC on the encapsulated IPv6 header would imply keeping state, which counters the stateless design intentions of the 6bed4 Server.  For this reason, this specification only describes sending RoHC traffic to a 6bed4 Peer, and permits a 6bed4 Server to drop all RoHC traffic without further notice.</t>

<t>The constraints on 6bed4 Peers and 6bed4 Servers for RoHC handling are detailed in Section <xref target="requirements"/>; their definition is such that traffic to a 6bed4 Peer may be compressed with RoHC, but when a new profile is introduced the receiving side may reject it through negative feedback.  This is interpreted as lack of support for that profile, and (robustly) avoids compression according to that particular profile.</t>

<t>Future specifications, as well as local uses of this specification may choose to overrule any of these definitions as long as it does not impair the robustness of RoHC; it is for example possible to use large CIDs or to equip a 6bed4 Server with RoHC capabilities; to name just one special use case, changes like these might prove useful on cellular links and other dedicated service channels.</t>

</section>


<section title="Requirements for 6bed4 Infrastructure Components" anchor="requirements">

<t>This section describes minimum requirements for 6bed4 Servers and
6bed4 Peers.</t>

<section title="Requirements for 6bed4 Servers" anchor="serverreqs">

<t>A 6bed4 Server MUST respond to well-formed Router Solicitations from any 6bed4 Peer, including non-local and non-member requests, by advertising the /114 prefix that starts with the well-known prefix TBD1::/32, followed by its own 6bed4 Address in the position of the Fallback 6bed4 Address, and the requesting 6bed4 Address as the Direct 6bed4 Address.  The 6bed4 Server MUST know its own 6bed4 Address as a combination of a configured public IPv4 address and the UDP port TBD2 and it MUST be reachable for anyone at the resulting 6bed4 Address.</t>

<t>A 6bed4 Server MUST filter incoming 6bed4 Frames as specified in <xref target="filtering"/>.  When a 6bed4 Frame is rejected on account of its Source 6bed4 Address, then the same Router Advertisement MUST be sent in response, with the added requirement that the falsely assumed /114 prefix from the source IPv6 address is retracted.</t>

<t>When responding to Neighbor Solicitation or Router Solicitation, a 6bed4 Server MUST copy any nonce and timing information from the request into the response.</t>

<t>A 6bed4 Server MAY publish Prefixes of its IPv6 address with lengths from /32+0 to /32+16 inclusive, through the Border Gateway Protocol (BGP), with at least the 6bed4 Address that it assigns in Router Advertisements as the Fallback 6bed4 Address, and MAY be published in BGP with a larger prefix.  The 6bed4 Server MUST receive all native IPv6 traffic sent to this published prefix.</t>

<t>A 6bed4 Server SHOULD forward IPv6 frames sent over native IPv6 routing to 6bed4-Prefixed Addresses after embedding them in a 6bed4 Frame; the Destination 6bed4 Address is the Direct 6bed4 Address if the Fallback 6bed4 Address matches the server's 6bed4 Address, or otherwise the Destination 6bed4 Address is the Fallback 6bed4 Address.</t>

<t>A 6bed4 Server SHOULD forward 6bed4 Frames destined for IPv6 Addresses that do not fall under the TBD1::/32 prefix.  This is done by unpacking the 6bed4 Frames, or in other words, by removing the UDP and IPv4 headers, and using native IPv6 routing for the submission of the unpacked frame.</t>

<t>A 6bed4 Server SHOULD forward 6bed4 Frames destined for a 6bed4-Prefixed Address to the next hop 6bed4 Address.  If the destination IPv6 Address holds the 6bed4 Server's address as the Fallback 6bed4 Address, then the next hop is the Direct 6bed4 Address found in the destination IPv6 address.  Otherwise, the next hop is the Fallback 6bed4 Address found in the destination IPv6 address.</t>

<t>The "SHOULD" conformance level in the last three paragraphs is a conscious limitation of the service, in support for commercial 6bed4 offerings that may want to limit their service offering to customers.  However, if the 6bed4 Server announces router one or more prefixes of at least 32 bits valued TBD1, then any IPv6 Frames whois source or destination IPv6 Address matches any of these announced prefixes MUST be forwarded as described by the last three paragraphs.</t>

<t>A 6bed4 Server MAY discard 6bed4-embedded RoHC packets, which can be recognised by their first nibble value being 14 or 15, instead of 6 for a plain IPv6 frame.  When dropping RoHC packets, a 6bed4 Server MUST NOT send 6bed4-embedded RoHC packets either.  When processing RoHC packets, the 6bed4 Server MUST behave in the same way as a 6bed4 Peer, and respect the rules of Section <xref target="rohc"/>.</t>

</section>


<section title="Requirements for 6bed4 Peers" anchor="peerreqs">

<t>A 6bed4 Peer SHOULD respond to well-formed Router Solicitations from any 6bed4 Peer, and to invalid incoming 6bed4 Frames from any source with a Router Advertisement, by advertising the /114 prefix that starts with the well-known prefix TBD1::/32, followed by its own 6bed4 Address in the position of the Fallback 6bed4 Address, and the requesting 6bed4 Address as the Direct 6bed4 Address.  The 6bed4 Peer may obtain its own 6bed4 Address from the Destination 6bed4 Address of the incoming 6bed4 Frame.</t>

<t>A 6bed4 Peer MUST filter incoming 6bed4 Frames as specified in <xref target="filtering"/>.  When a 6bed4 Frame is rejected on account of its Source 6bed4 Address, then the same Router Advertisement MUST be sent in response, with the added requirement that the falsely assumed /114 prefix from the source IPv6 address is retracted.</t>

<t>When setting up a 6bed4 Connection to a remote 6bed4 Address, a 6bed4 Peer SHOULD prefer any address for the local side of the 6bed4 Connection that starts with the same /64 prefix as the remote 6bed4 Peer's.  If no such address is available locally, it is RECOMMENDED to acquire one by sending a Router Solicitation to the remote peer's Fallback and/or Direct 6bed4 Address.</t>

<t>When communicating over a 6bed4 Connection, it is RECOMMENDED that a 6bed4 Peer attempts to setup a Direct 6bed4 Connection according to the Opportunistic Peering procedures described in <xref target="opportunism"/>.  The minimum implementation required is based on Neighbor Solicitation, as specified in <xref target="neighboropportunisticpeering"/>.</t>

<t>A 6bed4 Peer MUST respond to received Neighbor Solicitation messages with Neighbor Discovery messages, to implement Opportunistic Peering as specified in <xref target="neighboropportunisticpeering"/>.  It MAY also respond to other mechanisms for Opportunistic Peering as specified in the other sub-sections of <xref target="opportunism"/>.</t>

<t>When receiving 6bed4 Frames over a Direct 6bed4 Connection while not being setup to perform direct 6bed4 Peering to the Source 6bed4 Address, a 6bed4 Peer MUST work towards Opportunistic Peering, and Neighbor Solicitation MUST be one of the opportunistic mechanisms tried before considering failure.  If attempts towards Opportunistic Peering are already in motion for the same remote 6bed4 Peer, then its result may be awaited first.  If attempts towards Opportunistic Peering have recently been shown to fail, then the attempt MAY be foregone.</t>

<t>A 6bed4 Peer SHOULD send a nonce and timing information <xref target="RFC6496"/> in any sent Neighbor Solicitation and Router Solicitation.</t>

<t>When responding to Neighbor Solicitation or Router Solicitation, a 6bed4 Peer MUST copy any nonce and timing information from the request into the response.</t>

<t>A 6bed4 Peer SHOULD send keepalive frames to keep the UDP/IPv4 Stream open for active 6bed4 Connections.  A keepalive frame MAY be a valid IPv6 frame, or it may be an empty message embedded in UDP and IPv4 as would have been done for an IPv6 frame.  It MAY be sent with an IPv4 Time To Live that is so low that the keepalive frame just makes it to the public Internet, after having crossed local NAT routers and firewalls.  The timing interval of a keepalive frame SHOULD be a user setting, and it MAY by default be set to a safe low value of 30 seconds.</t>

<t>When received over a Direct 6bed4 Connection, a 6bed4 Peer MUST accept 6bed4 Frames with initial nibble values 14 and 15.  It must process them as RoHC packets, adhering to the rules in Section <xref target="rohc"/>.  In case of an IR packet that mentions an unsupported profile number, it MUST respond with a STATIC-NACK; note that it is permitted for an implementation to support no profile numbers at all, and send a STATIC-NACK in response to all IR packets.  Compressed RoHC packets that arrive under supported profiles are reconstructed into 6bed4 Frames and are then treated like freshly arrived 6bed4 Frames that had not been compressed.</t>

<t>A 6bed4 Peer MAY attempt RoHC compression over Direct 6bed4 Connections.  It may introduce any profile number that it wants, but should be prepared to deal with (repeated) STATIC-NACK on an IR packet to indicate that the recipient is not able to engage in that profile.  If this happens, the sender SHOULD back off temporarily or definately for the given 6bed4 Connection and/or the remote 6bed4 Address.  To limit loss of 6bed4 Frames caused by IR packet rejections, a 6bed4 Peers SHOULD NOT include a payload with an IR packet.</t>

<t>A 6bed4 Peer SHOULD deliver any 6bed4 Frame by unwrapping it (meaning, removing the IPv4 and UDP headers) and locally process the contained IPv6 frame, and it should accept local IPv6 frames originating at one of its local 6bed4-Prefixed Addresses, and wrap it into UDP and IPv4 to send to the destination, either to the Direct or Fallback 6bed4 Address contained in the IPv6 destination address.</t>

</section>


</section>


<section title="Implementation Considerations">

<t>One potential implementation of a 6bed4 tunnel interface would exploit
the Neighbor Cache in an IPv6 host to facilitate storage and timing of
the various neighboring relationships.  Indeed, the timeouts of such
relations are generally shorter than NAT mapping timeouts.  It should
however be noted that not all Neighbor Caches are designed for large-scale
operation, and that an active host could choke on that.  Furthermore,
there is no keepalive mechanism built into such neighbor caches, which
means that one or more peering relations could loose their address when
no traffic is exchanged for some time.</t>

<t>For ISPs that do not provide 6bed4, there is no problem to reach out to
more distant 6bed4 service providers.  It is even thinkable that such a third-party
service would be offered on a commercial basis, and that payload traffic through
the service would only be handled when it either passes to or from a
customer's registered address (range).  Such a service provider obviously
should not announce that it can route the TBD1::/32 prefix.</t>

<t>Although this specification speaks only of UDP as a transport for 6bed4,
it is possible to add TCP as a fallback protocol if the code of the 6bed4 Peer
and 6bed4 Server agree to that.  Although SCTP would be more suitable, it would
be uncommon to find a situation where that is present and UDP is not.  What is
common is that UDP is banned while TCP is not.  Such cases could
benefit from a fallback to TCP.  The format of the messages exchanged would
be precisely the same, except that the transmission happens to be ordered and
guaranteed.  As one more option to cator to failed Internet installations,
one could even consider supporting TCP over port 80 or 443 instead of the
standard port.  In all cases, the 6bed4 Server may now need be hold state for
all connected 6bed4 Peers, and choose whether to contact them over TCP or over UDP.
This can be remedied in various ways, including
differentiation between different kinds of 6bed4 Peers through the 6bed4 Address of the server.
This specification does not prescribe how non-UDP transports could be used and
generally leaves it to local protocol extensions.</t>

<t>Another option based on protocol extensions to which 6bed4 Server and
6bed4 Peer could agree, is to apply encryption to the information exchanged.
Such facilities are not part of this specification.</t>

<t>A few situations call for coordination between 6bed4 Infrastructure
components.  This will take place under the domain name 6bed4.net for
as long as the TBD1::/32 prefix and the TBD2 port are allocated for 6bed4.
The precise methods are not detailed here because it does not concern the
core communication protocols of the 6bed4 tunneling mechanism.
One thing coordinated under 6bed4.net is an service where Autonomous
Systems that announce TBD1::/32 routing must register all IPv4 addresses
of 6bed4 Servers that could pass on 6bed4 traffic to a machine with a
longer prefix that did not make it through to all parts of the Internet.</t>

</section>

OLD OLD OLD -->


<section title="IANA Considerations" anchor="iana">

<t>This specification reserves a 32-bit address prefix TBD1::/32 in the IPv6
address space assigned to the IANA IPv6 Special-Purpose Address Registry.
The prefix will be exclusively used for 6bed4
addresses, and further assigned as defined in <xref target="_6bed4net.prefix.6bed4"/>.
Addresses under this prefix can be used as source and destination addresses,
as they are globally routable.  The termination date for the allocation falls
ten years after the publication date of this specification in the
Request For Comments series; future standardisation work could
modify the end date if this is considered useful.</t>

<t>This specification also reserves Port TBD2 from the pools of
UDP ports, TCP ports and SCTP ports, subject to possible updates
in follow-up specifications.</t>

<t>The port TBD2 will be the port on which 6bed4routers
provide their services.  These servers form a public resource,
and remote peers have no mechanism other than the standardised port
to know how to contact an arbitrary 6bed4 Server of which only
the Fallback IPv4 Address was found in an IPv6 destination address
falling under the 6bed4 prefix TBD1::/32.</t>

<t>
<cref source="Rick">

Requests to IANA / to be removed after processing:

The requested assignment for TBD1 is 2001:64, so TBD1::/32 allocates 2001:64::/32 from 2001::/23
which is suggested (with the 6BONE example) in RFC 2928 and
https://www.iana.org/assignments/ipv6-unicast-address-assignments/ipv6-unicast-address-assignments.xhtml

The requested assignment for TBD2 is 25790, which is what we currently use in
our code and experimental deployments.

As per RFC 6335, this will probably be assigned under IETF Review or IESG Approval
_or_ Expert Review, all defined in RFC 5226.  Note that IETF Review is banned
for independent submissions under https://www.rfc-editor.org/about/independent/
and IESG Approval is not a very common procedure.  For Expert Review, it is
necessary to document clearly that a Dynamic Port is required; this is the case
because clients have no means to infer the port at which to contact a server or
a peer.  Especially for peers, whose addresses are inferred from their IPv6
address within the 6bed4 address space, there is no derivation mechanism for
these ports; and it is the ability to communicate directly with peers that
sets this mechanism apart as extremely scalable and apt for VoIP applications.

</cref>
</t>

</section>


<section title="Security Considerations" anchor="security">

<t>Tunneling mechanisms must always be on their guard for wrapped packets
containing false origins <xref target="RFC6169"/>.  To shield against this, 6bed4 ensures that the
source IPv4 address and UDP port of the together match either the Direct or
Fallback 6bed4 Address contained in the source IPv6 address.</t>

<t>Note that this facility works best when address filtering <xref target="BCP38"/>
is applied.  In lieu of authentication facilities for frame source,
the best that the 6bed4 tunnel can do is to avoid worsening the problems of
incomplete address filtering.</t>

<t>One exception arises with the possibility that a target 6bed4-Prefixed
Address publishes a /32+16 Prefix which is not seen everywhere on the
Internet; or that such a prefix is not actually published at all.  In such
situations, a 6bed4 Frame may be routed to a TBD1::/32 route, which passes
it on to the Fallback 6bed4 Address contained in the IPv6 destination
address.  The list of routers that can pass on such traffic will generally
be limited, and will be maintained externally to this specification, but
documented on 6bed4.net.  Routes announced to larger IP space than owned
by the publishing Anonymous System MUST be registered on 6bed4.net so as
to distinguish them from abuse.  The domain will publish processible
information that helps 6bed4 Servers to recognise this distinction too.</t>

<t>It is important to realise that 6bed4 bypasses NAT and Firewalls.
This is a feature inasfar as it enables peer-to-peer connectivity, but
it also implies a responsibility to not lightly attach services to a
6bed4-Prefixed Address.  There is no protection, other than what is
being added.  Specifically noteworthy is that the operator of the
6bed4 Server cannot implement filtering on behalf of their customers;
the ability to use Direct 6bed4 Connections would bypass this, and
since this could happen at any time such filtering could not even
be realiably made connection-aware.</t>

</section>

<section title="Acknowledgements">

<t>This work has evolved from a simple, and perhaps simplistic protocol to
its current form.  I owe gratitude to many who contributed.</t>

<t>Special thanks go to SURFnet, for generally supporting the idea of 6bed4
and providing long-term
support for the first public 6bed4router, as well as supporting the expansion
of the initial tunnel investigation work into a generally useful publication
<xref target="RFC7059"/>.</t>

<t>Thanks for financial support in developing phases of the specification and
coding of 6bed4 are due towards NLnet Foundation, as well as SURFnet and
SIDNfonds.</t>

<t>I owe gratitude to the NLUUG, ISOC NL and RIPE communities for discussing
prior tunnel designs and pointing out scaling and
routing problems; although the protocol has become more complex
it also has become more reliable and, I think, more generally acceptable.</t>

<t>Many thanks to Henri Manson for supporting me over a long time in
experimental development and many, many tests.</t>

<t>Finally, the work in this tunnel design called for a creative mind set
in which technical concepts were highly fluid and changing.
Although it would be difficult to point out a
direct link or assign an economic figure, the ability to think in
such a mode has clearly been influenced by independent,
thought-provoking, boundary-breaking expression by the many
artists whose work I have been able to enjoy.
I cherish art in all its forms for its incredible power to help us
be imaginative and innovative in the pragmatic field of technology.</t>

</section>

</middle>


<back>

<references title="Normative References">

<reference anchor="IEEE-EUI64">
<front>
<title>Guidelines for 64-bit Global Identifier (EUI-64TM)</title>
<author>
<organization>IEEE</organization>
</author>
<date year="2013" day="23" month="December" />
</front>
<!-- <seriesInfo name="IEEE Std" value="802.1Q" /> -->
<format type='PDF' octets='124241' target='http://standards.ieee.org/develop/regauth/tut/eui64.pdf' />
</reference>

<!--
<reference anchor='RFC1918'>

<front>
<title>Address Allocation for Private Internets</title>
<author initials='Y.' surname='Rekhter' fullname='Yakov Rekhter'>
<organization>Cisco systems</organization>
<address>
<postal>
<street>170 West Tasman Drive</street>
<city>San Jose</city>
<region>CA</region>
<code>95134-1706</code>
<country>US</country></postal>
<phone>+1 914 528 0090</phone>
<facsimile>+1 408 526 4952</facsimile>
<email>yakov@cisco.com</email></address></author>
<author initials='R.' surname='Moskowitz' fullname='Robert G. Moskowitz'>
<organization>Chrysler Corporation</organization>
<address>
<postal>
<street>25999 Lawrence Ave</street>
<city>Center Line</city>
<region>MI</region>
<code>48015</code>
<country>US</country></postal>
<phone>+1 810 758 8212</phone>
<facsimile>+1 810 758 8173</facsimile>
<email>rgm3@is.chrysler.com</email></address></author>
<author initials='D.' surname='Karrenberg' fullname='Daniel Karrenberg'>
<organization>RIPE Network Coordination Centre</organization>
<address>
<postal>
<street>Kruislaan 409</street>
<city>Amsterdam</city>
<region />
<code>1098 SJ</code>
<country>NL</country></postal>
<phone>+31 20 5925065</phone>
<facsimile>+31 20 5925090</facsimile>
<email>Daniel.Karrenberg@ripe.net</email></address></author>
<author initials='G.' surname='Groot' fullname='Geert Jan de Groot'>
<organization>RIPE Network Coordination Centre</organization>
<address>
<postal>
<street>Kruislaan 409</street>
<city>Amsterdam</city>
<region />
<code>1098 SJ</code>
<country>NL</country></postal>
<phone>+31 20 5925065</phone>
<facsimile>+31 20 5925090</facsimile>
<email>GeertJan.deGroot@ripe.net</email></address></author>
<author initials='E.' surname='Lear' fullname='Eliot Lear'>
<organization>Silicon Graphics, Inc.</organization>
<address>
<postal>
<street>2011 N. Shoreline Blvd.</street>
<street>Mail Stop 15-730</street>
<city>Mountain View</city>
<region>CA</region>
<code>94043-1389</code>
<country>US</country></postal>
<phone>+1 415 960 1980</phone>
<facsimile>+1 415 961 9584</facsimile>
<email>lear@sgi.com</email></address></author>
<date year='1996' month='February' /></front>

<seriesInfo name='BCP' value='5' />
<seriesInfo name='RFC' value='1918' />
<format type='TXT' octets='22270' target='http://www.rfc-editor.org/rfc/rfc1918.txt' />
</reference>
-->

<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>

<reference anchor='RFC2372'>

<front>
<title abbrev='TIP'>Transaction Internet Protocol - Requirements and Supplemental Information</title>
<author initials='K.' surname='Evans' fullname='Keith Evans'>
<organization>Tandem Computers Inc, LOC 252-30</organization>
<address>
<postal>
<street>5425 Stevens Creek Blvd</street>
<street>Santa Clara</street>
<street>CA 95051-7200</street>
<country>USA</country></postal>
<phone>+1 (408) 285 5314</phone>
<facsimile>+1 (408) 285 5245</facsimile>
<email>Keith.Evans@Tandem.Com</email></address></author>
<author initials='J.' surname='Klein' fullname='Johannes Klein'>
<organization>Tandem Computers Inc.</organization>
<address>
<postal>
<street>10555 Ridgeview Court</street>
<street>Cupertino</street>
<street>CA 95014-0789</street>
<country>USA</country></postal>
<phone>+1 (408) 285 0453</phone>
<facsimile>+1 (408) 285 9818</facsimile>
<email>Johannes.Klein@Tandem.Com</email></address></author>
<author initials='J.' surname='Lyon' fullname='Jim Lyon'>
<organization>Microsoft Corporation</organization>
<address>
<postal>
<street>One Microsoft Way</street>
<street>Redmond</street>
<street>WA  98052-6399</street>
<country>USA</country></postal>
<phone>+1 (206) 936 0867</phone>
<facsimile>+1 (206) 936 7329</facsimile>
<email>JimLyon@Microsoft.Com</email></address></author>
<date year='1998' month='July' />
<area>Applications</area>
<keyword>transaction</keyword>
<abstract>
<t>
   This document describes the purpose (usage scenarios), and
   requirements for the Transaction Internet Protocol . It is
   intended to help qualify the necessary features and functions of the
   protocol. It also provides supplemental information to aid
   understanding and facilitate implementation of the TIP protocol.
</t></abstract></front>

<seriesInfo name='RFC' value='2372' />
<format type='TXT' octets='53699' target='http://www.rfc-editor.org/rfc/rfc2372.txt' />
<format type='XML' octets='51926' target='http://xml.resource.org/public/rfc/xml/rfc2372.xml' />
</reference>

<!--
<reference anchor='RFC3056'>

<front>
<title>Connection of IPv6 Domains via IPv4 Clouds</title>
<author initials='B.' surname='Carpenter' fullname='B. Carpenter'>
<organization /></author>
<author initials='K.' surname='Moore' fullname='K. Moore'>
<organization /></author>
<date year='2001' month='February' />
<abstract>
<t>This memo specifies an optional interim mechanism for IPv6 sites to communicate with each other over the IPv4 network without explicit tunnel setup, and for them to communicate with native IPv6 domains via relay routers. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3056' />
<format type='TXT' octets='54902' target='http://www.rfc-editor.org/rfc/rfc3056.txt' />
</reference>
-->

<reference anchor='RFC3095'>

<front>
<title>RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'>
<organization /></author>
<author initials='C.' surname='Burmeister' fullname='C. Burmeister'>
<organization /></author>
<author initials='M.' surname='Degermark' fullname='M. Degermark'>
<organization /></author>
<author initials='H.' surname='Fukushima' fullname='H. Fukushima'>
<organization /></author>
<author initials='H.' surname='Hannu' fullname='H. Hannu'>
<organization /></author>
<author initials='L-E.' surname='Jonsson' fullname='L-E. Jonsson'>
<organization /></author>
<author initials='R.' surname='Hakenberg' fullname='R. Hakenberg'>
<organization /></author>
<author initials='T.' surname='Koren' fullname='T. Koren'>
<organization /></author>
<author initials='K.' surname='Le' fullname='K. Le'>
<organization /></author>
<author initials='Z.' surname='Liu' fullname='Z. Liu'>
<organization /></author>
<author initials='A.' surname='Martensson' fullname='A. Martensson'>
<organization /></author>
<author initials='A.' surname='Miyazaki' fullname='A. Miyazaki'>
<organization /></author>
<author initials='K.' surname='Svanbro' fullname='K. Svanbro'>
<organization /></author>
<author initials='T.' surname='Wiebke' fullname='T. Wiebke'>
<organization /></author>
<author initials='T.' surname='Yoshimura' fullname='T. Yoshimura'>
<organization /></author>
<author initials='H.' surname='Zheng' fullname='H. Zheng'>
<organization /></author>
<date year='2001' month='July' />
<abstract>
<t>This document specifies a highly robust and efficient header compression scheme for RTP/UDP/IP (Real-Time Transport Protocol, User Datagram Protocol, Internet Protocol), UDP/IP, and ESP/IP (Encapsulating Security Payload) headers. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3095' />
<format type='TXT' octets='368746' target='http://www.rfc-editor.org/rfc/rfc3095.txt' />
</reference>

<reference anchor='RFC3261'>

<front>
<title>SIP: Session Initiation Protocol</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'>
<organization /></author>
<author initials='A.' surname='Johnston' fullname='A. Johnston'>
<organization /></author>
<author initials='J.' surname='Peterson' fullname='J. Peterson'>
<organization /></author>
<author initials='R.' surname='Sparks' fullname='R. Sparks'>
<organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'>
<organization /></author>
<author initials='E.' surname='Schooler' fullname='E. Schooler'>
<organization /></author>
<date year='2002' month='June' />
<abstract>
<t>This document describes Session Initiation Protocol (SIP), an application-layer control (signaling) protocol for creating, modifying, and terminating sessions with one or more participants.  These sessions include Internet telephone calls, multimedia distribution, and multimedia conferences. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3261' />
<format type='TXT' octets='647976' target='http://www.rfc-editor.org/rfc/rfc3261.txt' />
</reference>

<reference anchor='RFC3489'>

<front>
<title>STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='J.' surname='Weinberger' fullname='J. Weinberger'>
<organization /></author>
<author initials='C.' surname='Huitema' fullname='C. Huitema'>
<organization /></author>
<author initials='R.' surname='Mahy' fullname='R. Mahy'>
<organization /></author>
<date year='2003' month='March' />
<abstract>
<t>Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs) (STUN) is a lightweight protocol that allows applications to discover the presence and types of NATs and firewalls between them and the public Internet.  It also provides the ability for applications to determine the public Internet Protocol (IP) addresses allocated to them by the NAT.  STUN works with many existing NATs, and does not require any special behavior from them.  As a result, it allows a wide variety of applications to work through existing NAT infrastructure. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3489' />
<format type='TXT' octets='117562' target='http://www.rfc-editor.org/rfc/rfc3489.txt' />
</reference>

<reference anchor='RFC4291'>

<front>
<title>IP Version 6 Addressing Architecture</title>
<author initials='R.' surname='Hinden' fullname='R. Hinden'>
<organization /></author>
<author initials='S.' surname='Deering' fullname='S. Deering'>
<organization /></author>
<date year='2006' month='February' />
<abstract>
<t>This specification defines the addressing architecture of the IP Version 6 (IPv6) protocol. The document includes the IPv6 addressing model, text representations of IPv6 addresses, definition of IPv6 unicast addresses, anycast addresses, and multicast addresses, and an IPv6 node's required addresses.&lt;/t>&lt;t> This document obsoletes RFC 3513, "IP Version 6 Addressing Architecture". [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4291' />
<format type='TXT' octets='52897' target='http://www.rfc-editor.org/rfc/rfc4291.txt' />
</reference>

<reference anchor='RFC4380'>

<front>
<title>Teredo: Tunneling IPv6 over UDP through Network Address Translations (NATs)</title>
<author initials='C.' surname='Huitema' fullname='C. Huitema'>
<organization /></author>
<date year='2006' month='February' />
<abstract>
<t>We propose here a service that enables nodes located behind one or more IPv4 Network Address Translations (NATs) to obtain IPv6 connectivity by tunneling packets over UDP; we call this the Teredo service.  Running the service requires the help of "Teredo servers" and "Teredo relays".  The Teredo servers are stateless, and only have to manage a small fraction of the traffic between Teredo clients; the Teredo relays act as IPv6 routers between the Teredo service and the "native" IPv6 Internet.  The relays can also provide interoperability with hosts using other transition mechanisms such as "6to4". [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4380' />
<format type='TXT' octets='132607' target='http://www.rfc-editor.org/rfc/rfc4380.txt' />
</reference>

<reference anchor='RFC4787'>

<front>
<title>Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</title>
<author initials='F.' surname='Audet' fullname='F. Audet'>
<organization /></author>
<author initials='C.' surname='Jennings' fullname='C. Jennings'>
<organization /></author>
<date year='2007' month='January' />
<abstract>
<t>This document defines basic terminology for describing different types of Network Address Translation (NAT) behavior when handling Unicast UDP and also defines a set of requirements that would allow many applications, such as multimedia communications or online gaming, to work consistently.  Developing NATs that meet this set of requirements will greatly increase the likelihood that these applications will function properly.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='127' />
<seriesInfo name='RFC' value='4787' />
<format type='TXT' octets='68693' target='http://www.rfc-editor.org/rfc/rfc4787.txt' />
</reference>

<reference anchor='RFC4861'>

<front>
<title>Neighbor Discovery for IP version 6 (IPv6)</title>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='E.' surname='Nordmark' fullname='E. Nordmark'>
<organization /></author>
<author initials='W.' surname='Simpson' fullname='W. Simpson'>
<organization /></author>
<author initials='H.' surname='Soliman' fullname='H. Soliman'>
<organization /></author>
<date year='2007' month='September' />
<abstract>
<t>This document specifies the Neighbor Discovery protocol for IP Version 6.  IPv6 nodes on the same link use Neighbor Discovery to discover each other's presence, to determine each other's link-layer addresses, to find routers, and to maintain reachability information about the paths to active neighbors. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4861' />
<format type='TXT' octets='235106' target='http://www.rfc-editor.org/rfc/rfc4861.txt' />
</reference>

<reference anchor='RFC4862'>

<front>
<title>IPv6 Stateless Address Autoconfiguration</title>
<author initials='S.' surname='Thomson' fullname='S. Thomson'>
<organization /></author>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='T.' surname='Jinmei' fullname='T. Jinmei'>
<organization /></author>
<date year='2007' month='September' />
<abstract>
<t>This document specifies the steps a host takes in deciding how to autoconfigure its interfaces in IP version 6.  The autoconfiguration process includes generating a link-local address, generating global addresses via stateless address autoconfiguration, and the Duplicate Address Detection procedure to verify the uniqueness of the addresses on a link. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4862' />
<format type='TXT' octets='72482' target='http://www.rfc-editor.org/rfc/rfc4862.txt' />
</reference>

<reference anchor='RFC4941'>

<front>
<title>Privacy Extensions for Stateless Address Autoconfiguration in IPv6</title>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='R.' surname='Draves' fullname='R. Draves'>
<organization /></author>
<author initials='S.' surname='Krishnan' fullname='S. Krishnan'>
<organization /></author>
<date year='2007' month='September' />
<abstract>
<t>Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers.  Addresses are formed by combining network prefixes with an interface identifier.  On an interface that contains an embedded IEEE Identifier, the interface identifier is typically derived from it.  On other interface types, the interface identifier is generated through other means, for example, via random number generation.  This document describes an extension to IPv6 stateless address autoconfiguration for interfaces whose interface identifier is derived from an IEEE identifier.  Use of the extension causes nodes to generate global scope addresses from interface identifiers that change over time, even in cases where the interface contains an embedded IEEE identifier.  Changing the interface identifier (and the global scope addresses generated from it) over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions actually correspond to the same node. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4941' />
<format type='TXT' octets='56699' target='http://www.rfc-editor.org/rfc/rfc4941.txt' />
</reference>

<reference anchor='RFC4960'>

<front>
<title>Stream Control Transmission Protocol</title>
<author initials='R.' surname='Stewart' fullname='R. Stewart'>
<organization /></author>
<date year='2007' month='September' />
<abstract>
<t>This document obsoletes RFC 2960 and RFC 3309. It describes the Stream Control Transmission Protocol (SCTP). SCTP is designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks, but is capable of broader applications.&lt;/t>&lt;t> SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP. It offers the following services to its users:&lt;/t>&lt;t> -- acknowledged error-free non-duplicated transfer of user data,&lt;/t>&lt;t> -- data fragmentation to conform to discovered path MTU size,&lt;/t>&lt;t> -- sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages,&lt;/t>&lt;t> -- optional bundling of multiple user messages into a single SCTP packet, and&lt;/t>&lt;t> -- network-level fault tolerance through supporting of multi-homing at either or both ends of an association.&lt;/t>&lt;t> The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4960' />
<format type='TXT' octets='346022' target='http://www.rfc-editor.org/rfc/rfc4960.txt' />
</reference>

<reference anchor='RFC5389'>

<front>
<title>Session Traversal Utilities for NAT (STUN)</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='R.' surname='Mahy' fullname='R. Mahy'>
<organization /></author>
<author initials='P.' surname='Matthews' fullname='P. Matthews'>
<organization /></author>
<author initials='D.' surname='Wing' fullname='D. Wing'>
<organization /></author>
<date year='2008' month='October' />
<abstract>
<t>Session Traversal Utilities for NAT (STUN) is a protocol that serves as a tool for other protocols in dealing with Network Address Translator (NAT) traversal. It can be used by an endpoint to determine the IP address and port allocated to it by a NAT. It can also be used to check connectivity between two endpoints, and as a keep-alive protocol to maintain NAT bindings. STUN works with many existing NATs, and does not require any special behavior from them.&lt;/t>&lt;t> STUN is not a NAT traversal solution by itself. Rather, it is a tool to be used in the context of a NAT traversal solution. This is an important change from the previous version of this specification (RFC 3489), which presented STUN as a complete solution.&lt;/t>&lt;t> This document obsoletes RFC 3489. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5389' />
<format type='TXT' octets='125650' target='http://www.rfc-editor.org/rfc/rfc5389.txt' />
</reference>

<reference anchor='RFC6169'>

<front>
<title>Security Concerns with IP Tunneling</title>
<author initials='S.' surname='Krishnan' fullname='S. Krishnan'>
<organization /></author>
<author initials='D.' surname='Thaler' fullname='D. Thaler'>
<organization /></author>
<author initials='J.' surname='Hoagland' fullname='J. Hoagland'>
<organization /></author>
<date year='2011' month='April' />
<abstract>
<t>A number of security concerns with IP tunnels are documented in this memo.  The intended audience of this document includes network administrators and future protocol developers.  The primary intent of this document is to raise the awareness level regarding the security issues with IP tunnels as deployed and propose strategies for the mitigation of those issues. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6169' />
<format type='TXT' octets='45018' target='http://www.rfc-editor.org/rfc/rfc6169.txt' />
</reference>

<reference anchor='RFC6455'>

<front>
<title>The WebSocket Protocol</title>
<author initials='I.' surname='Fette' fullname='I. Fette'>
<organization /></author>
<author initials='A.' surname='Melnikov' fullname='A. Melnikov'>
<organization /></author>
<date year='2011' month='December' />
<abstract>
<t>The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code.  The security model used for this is the origin-based security model commonly used by web browsers.  The protocol consists of an opening handshake followed by basic message framing, layered over TCP.  The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or &amp;lt;iframe&amp;gt;s and long polling). [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6455' />
<format type='TXT' octets='162067' target='http://www.rfc-editor.org/rfc/rfc6455.txt' />
</reference>

<reference anchor='RFC6496'>

<front>
<title>Secure Proxy ND Support for SEcure Neighbor Discovery (SEND)</title>
<author initials='S.' surname='Krishnan' fullname='S. Krishnan'>
<organization /></author>
<author initials='J.' surname='Laganier' fullname='J. Laganier'>
<organization /></author>
<author initials='M.' surname='Bonola' fullname='M. Bonola'>
<organization /></author>
<author initials='A.' surname='Garcia-Martinez' fullname='A. Garcia-Martinez'>
<organization /></author>
<date year='2012' month='February' />
<abstract>
<t>SEcure Neighbor Discovery (SEND) specifies a method for securing Neighbor Discovery (ND) signaling against specific threats.  As defined today, SEND assumes that the node sending an ND message is the owner of the address from which the message is sent and/or possesses a key that authorizes the node to act as a router, so that it is in possession of the private key or keys used to generate the digital signature on each message.  This means that the Proxy ND signaling performed by nodes that do not possess knowledge of the address owner's private key and/or knowledge of a router's key cannot be secured using SEND.  This document extends the current SEND specification in order to secure Proxy ND operation.  This document defines an Experimental Protocol for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='6496' />
<format type='TXT' octets='57746' target='http://www.rfc-editor.org/rfc/rfc6496.txt' />
</reference>

<!--
<reference anchor='RFC6598'>

<front>
<title>IANA-Reserved IPv4 Prefix for Shared Address Space</title>
<author initials='J.' surname='Weil' fullname='J. Weil'>
<organization /></author>
<author initials='V.' surname='Kuarsingh' fullname='V. Kuarsingh'>
<organization /></author>
<author initials='C.' surname='Donley' fullname='C. Donley'>
<organization /></author>
<author initials='C.' surname='Liljenstolpe' fullname='C. Liljenstolpe'>
<organization /></author>
<author initials='M.' surname='Azinger' fullname='M. Azinger'>
<organization /></author>
<date year='2012' month='April' />
<abstract>
<t>This document requests the allocation of an IPv4 /10 address block to be used as Shared Address Space to accommodate the needs of Carrier- Grade NAT (CGN) devices. It is anticipated that Service Providers will use this Shared Address Space to number the interfaces that connect CGN devices to Customer Premises Equipment (CPE).&lt;/t>&lt;t> Shared Address Space is distinct from RFC 1918 private address space because it is intended for use on Service Provider networks. However, it may be used in a manner similar to RFC 1918 private address space on routing equipment that is able to do address translation across router interfaces when the addresses are identical on two different interfaces. Details are provided in the text of this document.&lt;/t>&lt;t> This document details the allocation of an additional special-use IPv4 address block and updates RFC 5735. This memo documents an Internet Best Current Practice.</t></abstract></front>

<seriesInfo name='BCP' value='153' />
<seriesInfo name='RFC' value='6598' />
<format type='TXT' octets='22055' target='http://www.rfc-editor.org/rfc/rfc6598.txt' />
</reference>
-->

<reference anchor='RFC6724'>

<front>
<title>Default Address Selection for Internet Protocol Version 6 (IPv6)</title>
<author initials='D.' surname='Thaler' fullname='D. Thaler'>
<organization /></author>
<author initials='R.' surname='Draves' fullname='R. Draves'>
<organization /></author>
<author initials='A.' surname='Matsumoto' fullname='A. Matsumoto'>
<organization /></author>
<author initials='T.' surname='Chown' fullname='T. Chown'>
<organization /></author>
<date year='2012' month='September' />
<abstract>
<t>This document describes two algorithms, one for source address selection and one for destination address selection. The algorithms specify default behavior for all Internet Protocol version 6 (IPv6) implementations. They do not override choices made by applications or upper-layer protocols, nor do they preclude the development of more advanced mechanisms for address selection. The two algorithms share a common context, including an optional mechanism for allowing administrators to provide policy that can override the default behavior. In dual-stack implementations, the destination address selection algorithm can consider both IPv4 and IPv6 addresses -- depending on the available source addresses, the algorithm might prefer IPv6 addresses over IPv4 addresses, or vice versa.&lt;/t>&lt;t> Default address selection as defined in this specification applies to all IPv6 nodes, including both hosts and routers. This document obsoletes RFC 3484. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6724' />
<format type='TXT' octets='74407' target='http://www.rfc-editor.org/rfc/rfc6724.txt' />
</reference>

<reference anchor='RFC7059'>

<front>
<title>A Comparison of IPv6-over-IPv4 Tunnel Mechanisms</title>
<author initials='S.' surname='Steffann' fullname='S. Steffann'>
<organization /></author>
<author initials='I.' surname='van Beijnum' fullname='I. van Beijnum'>
<organization /></author>
<author initials='R.' surname='van Rein' fullname='R. van Rein'>
<organization /></author>
<date year='2013' month='November' />
<abstract>
<t>This document provides an overview of various ways to tunnel IPv6 packets over IPv4 networks.  It covers mechanisms in current use, touches on several mechanisms that are now only of historic interest, and discusses some newer tunnel mechanisms that are not widely used at the time of publication.  The goal of the document is helping people with an IPv6-in-IPv4 tunneling need to select the mechanisms that may apply to them.</t></abstract></front>

<seriesInfo name='RFC' value='7059' />
<format type='TXT' octets='98886' target='http://www.rfc-editor.org/rfc/rfc7059.txt' />
</reference>

<?rfc include="reference.RFC.2474.xml"?>
<?rfc include="reference.RFC.3513.xml"?>
<?rfc include="reference.RFC.3168.xml"?>
<?rfc include="reference.RFC.4193.xml"?>
<?rfc include="reference.RFC.5175.xml"?>

<reference anchor='BCP38'>
<front>
<title>Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing</title>
<author initials='P.' surname='Ferguson' fullname='P. Ferguson'>
<organization /></author>
<author initials='D.' surname='Senie' fullname='D. Senie'>
<organization /></author>
<date year='2000' month='May' />
<abstract>
<t>This paper discusses a simple, effective, and straightforward method for using ingress traffic filtering to prohibit DoS (Denial of Service) attacks which use forged IP addresses to be propagated from 'behind' an Internet Service Provider's (ISP) aggregation point.  This document specifies an Internet Best Current P
ractices for the Internet Community, and requests discussion and suggestions for
 improvements.</t></abstract></front>
<seriesInfo name='BCP' value='38' />
<seriesInfo name='RFC' value='2827' />
<format type='TXT' octets='21258' target='http://www.rfc-editor.org/rfc/rfc2827.
txt' />
</reference>


<reference anchor="POTAROO" target="http://www.potaroo.net/ispcol/2011-04/teredo.html">
  <front>
    <title>Testing Teredo</title>
    <author initials="G." surname="Huston" fullname="Geoff Huston">
        <organization>APNIC</organization>
    </author>
    <date year="2011" month="April"/>
  </front>
</reference>


</references>


</back>

</rfc>
